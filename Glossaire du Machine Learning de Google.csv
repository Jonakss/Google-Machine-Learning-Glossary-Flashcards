<p><a name="AB_testing"></a>
</p><h2 class="hide-from-toc"> test A/B (A/B testing)</h2><p></p>
<p>Méthode statistique de comparaison d'au moins deux techniques, généralement une technique en place et une nouvelle technique concurrente. Le test A/B vise non seulement à déterminer la technique la plus performante, mais aussi si la différence est statistiquement significative. Généralement, le test A/B compare deux techniques sur la base d'une seule mesure. Il peut cependant être appliqué à n'importe quel nombre fini de techniques et de mesures.</p>
<p><a name="accuracy"></a>
</p><h2 class="hide-from-toc"> justesse (accuracy)</h2><p></p>
<p>Proportion de prédictions correctes d'un <a href="#classification_model"><strong>modèle de classification</strong></a>. Dans la <a href="#multi-class"><strong>classification à classes multiples</strong></a>, la justesse est définie comme suit :</p>
<div>
$$\text{Justesse} =
\frac{\text{Prédictions correctes}} {\text{Nombre total d'exemples}}$$
</div>

<p>Dans la <a href="#binary_classification"><strong>classification binaire</strong></a>, la justesse est définie ainsi :</p>
<div>
$$\text{Justesse} = \frac{\text{Vrais positifs} + \text{Vrais négatifs}}
                         {\text{Nombre total d'exemples}}$$
</div>

<p>Voir <a href="#TP"><strong>vrai positif</strong></a> et <a href="#TN"><strong>vrai négatif</strong></a>.</p>
<p><a name="activation_function"></a>
</p><h2 class="hide-from-toc">fonction d'activation (activation function)</h2><p></p>
<p>Fonction (par exemple <a href="#ReLU"><strong>ReLU</strong></a> ou <a href="#sigmoid_function"><strong>sigmoïde</strong></a>) qui utilise la somme pondérée de toutes les entrées de la couche précédente pour générer une valeur de sortie (généralement non linéaire) et la transmettre à la couche suivante.</p>
<p><a name="AdaGrad"></a>
</p><h2 class="hide-from-toc"> AdaGrad</h2><p></p>
<p>Algorithme complexe de descente de gradient qui redimensionne les gradients de chaque paramètre en attribuant à chacun des paramètres un <a href="#learning_rate"><strong>taux d'apprentissage</strong></a> indépendant. Pour une explication complète, consultez <a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf">cet article</a>.</p>
<p><a name="AUC"></a>
</p><h2 class="hide-from-toc"> AUC (aire sous la courbe ROC) (AUC (Area under the ROC Curve))</h2><p></p>
<p>Statistique d'évaluation qui envisage tous les <a href="#classification_threshold"><strong>seuils de classification</strong></a> possibles.</p>
<p>L'aire sous la <a href="#ROC">courbe ROC</a> correspond à la probabilité que le niveau de confiance d'un classificateur quant au fait qu'un exemple positif choisi aléatoirement soit effectivement positif soit supérieur au niveau de confiance quant au fait qu'un exemple négatif choisi aléatoirement soit positif.</p>

<p><a name="backpropagation"></a>
</p><h2 class="hide-from-toc"> rétropropagation (backpropagation)</h2><p></p>
<p>Algorithme principal utilisé pour exécuter la <a href="#gradient_descent"><strong>descente de gradient</strong></a> sur des <a href="#neural_network"><strong>réseaux de neurones</strong></a>. Les valeurs de sortie de chaque nœud sont d'abord calculées (et mises en cache) dans une propagation avant,
puis la <a href="https://en.wikipedia.org/wiki/Partial_derivative">dérivée partielle</a> de l'erreur pour chaque paramètre est calculée dans une rétropropagation via le graphe.</p>
<p><a name="baseline"></a>
</p><h2 class="hide-from-toc"> référence (baseline)</h2><p></p>
<p><a href="#model"><strong>Modèle</strong></a> simple ou heuristique utilisé comme point de référence pour comparer les performances d'un modèle. Une référence aide les développeurs de modèles à quantifier les performances minimales attendues pour un problème particulier.</p>
<p><a name="batch"></a>
</p><h2 class="hide-from-toc"> lot (batch)</h2><p></p>
<p>Ensemble d'exemples utilisés dans une <a href="#iteration"><strong>itération</strong></a> (c'est-à-dire, une mise à jour du <a href="#gradient"><strong>gradient</strong></a>) de l'<a href="#model_training"><strong>entraînement du modèle</strong></a>.</p>
<p>Voir aussi <a href="#batch_size"><strong>taille de lot</strong></a>.</p>
<p><a name="batch_size"></a>
</p><h2 class="hide-from-toc"> taille de lot (batch size)</h2><p></p>
<p>Nombre d'exemples d'un <a href="#batch"><strong>lot</strong></a>. Par exemple, la taille de lot de <a href="#SGD"><strong>SGD</strong></a> est 1, tandis que la taille de lot d'un <a href="#mini-batch"><strong>mini-lot</strong></a> est généralement comprise entre 10 et 1 000. La taille de lot est habituellement fixée pendant les processus d'apprentissage et d'inférence. Toutefois, TensorFlow accepte les tailles de lot dynamiques.</p>
<p><a name="bias"></a>
</p><h2 class="hide-from-toc"> biais (bias)</h2><p></p>
<p>Ordonnée à l'origine ou décalage par rapport à une origine. Le <strong>biais</strong> est noté <em>b</em> ou <i>w<sub>0</sub></i> dans les modèles de machine learning.  Par exemple, <em>b</em> représente le biais dans la formule suivante :</p>
<div>
$$y' = b + w_1x_1 + w_2x_2 + … w_nx_n$$
</div>

<p>À ne pas confondre avec le <a href="#prediction_bias"><strong>biais de prédiction</strong></a>.</p>
<p><a name="binary_classification"></a>
</p><h2 class="hide-from-toc"> classification binaire (binary classification)</h2><p></p>
<p>Type de tâche de classification qui prédit l'une des deux classes mutuellement exclusives. Par exemple, un modèle de machine learning qui classe les e-mails en tant que "spam" ou "non-spam" est un classificateur binaire.</p>
<p><a name="binning"></a>
</p><h2 class="hide-from-toc"> binning</h2><p></p>
<p>Voir <a href="#bucketing"><strong>binning (bucketing)</strong></a>.</p>
</p><p><a name="bucketing"></a>
</p><h2 class="hide-from-toc"> binning (bucketing)</h2><p></p>
<p>Conversion d'une caractéristique (généralement <a href="#continuous_feature"><strong>continue</strong></a>) en plusieurs caractéristiques binaires appelées "ensembles" ou "classes", habituellement en fonction d'une plage de valeurs. Par exemple, plutôt que de représenter une température comme une seule caractéristique continue à virgule flottante, vous pouvez scinder des plages de températures en classes distinctes. Si la sensibilité des données de température est d'un dixième de degré, toutes les températures comprises entre 0,0 et 15,0 peuvent être placées dans une même classe, celles comprises entre 15,1 et 30,0 dans une deuxième, et celles entre 30,1 et 50,0 dans une troisième.</p>

<p><a name="calibration_layer"></a>
</p><h2 class="hide-from-toc"> niveau de calibration (calibration layer)</h2><p></p>
<p>Ajustement réalisé après la prédiction, généralement pour prendre en compte le <a href="#prediction_bias"><strong>biais de prédiction</strong></a>. Les prédictions et les probabilités ajustées doivent correspondre à la distribution d'un ensemble observé d'étiquettes.</p>
<p><a name="candidate_sampling"></a>
</p><h2 class="hide-from-toc"> échantillonnage de candidats (candidate sampling)</h2><p></p>
<p>Optimisation réalisée lors de l'apprentissage, dans laquelle une probabilité est calculée pour toutes les étiquettes positives, en utilisant par exemple softmax, mais seulement pour un échantillon aléatoire d'étiquettes négatives. Si un exemple est étiqueté <em>beagle</em> et <em>chien</em>, l'échantillonnage de candidats calcule les probabilités prédites et les termes de pertes correspondants pour les sorties de classe <em>beagle</em> et <em>chien</em>, en plus d'un sous-ensemble aléatoire des classes restantes (<em>chat</em>, <em>sucette</em>, <em>clôture</em>). Le but est que les <a href="#negative_class"><strong>classes négatives</strong></a> puissent apprendre à partir d'un renforcement négatif moins fréquent tant que les <a href="#positive_class"><strong>classes positives</strong></a> sont correctement renforcées positivement, ce qui est effectivement observé empiriquement. L'intérêt de l'échantillonnage des candidats est d'améliorer l'efficacité du calcul en ne calculant pas les prédictions pour tous les négatifs.</p>
<p><a name="categorical_data"></a>
</p><h2 class="hide-from-toc"> données catégorielles (categorical data)</h2><p></p>
<p><a href="#feature"><strong>Caractéristiques</strong></a> avec un ensemble discret de valeurs possibles. Par exemple, une caractéristique catégorique nommée <code>house style</code>, avec l'ensemble discret de trois valeurs possibles suivant : <code>Tudor, ranch, colonial</code>. En représentant <code>house style</code> comme une donnée catégorielle, le modèle peut apprendre l'impact de chaque valeur <code>Tudor</code>, <code>ranch</code> et <code>colonial</code> sur la valeur immobilière.</p>
<p>Parfois, les valeurs de l'ensemble discret s'excluent mutuellement, et une seule valeur peut être appliquée à un exemple donné. Par exemple, la caractéristique catégorique <code>car maker</code> n'autoriserait probablement qu'une seule valeur (<code>Toyota</code>) pour chaque exemple.  Dans d'autres cas, plusieurs valeurs peuvent s'appliquer. Une voiture peut être peinte de différentes couleurs. Ainsi, la caractéristique catégorique <code>car color</code> autoriserait probablement plusieurs valeurs (par exemple, <code>red</code> et <code>white</code>) pour un exemple.</p>
<p>Les caractéristiques catégoriques sont parfois appelées <a href="#discrete_feature"><strong>caractéristiques discrètes</strong></a>.</p>
<p>À comparer aux <a href="#numerical_data"><strong>données numériques</strong></a>.</p>
<p><a name="centroid"></a>
</p><h2 class="hide-from-toc">centroïde (centroid)</h2><p></p>
<p>Centre d'un cluster déterminé par un algorithme <a href="#k-means"><strong>k-moyennes</strong></a> ou <a href="#k-median"><strong>k-médiane</strong></a>. Par exemple, si k est égal à 3, alors l'algorithme k-moyennes ou k-médiane trouve 3 centroïdes.</p>
<p><a name="checkpoint"></a>
</p><h2 class="hide-from-toc"> point de contrôle (checkpoint)</h2><p></p>
<p>Données qui capturent l'état des variables d'un modèle à un instant donné. Les points de contrôle permettent d'exporter les <a href="#weight"><strong>pondérations</strong></a> du modèle et de réaliser des apprentissages sur plusieurs sessions. Ils permettent aussi à l'apprentissage de se poursuivre en cas d'erreur (par exemple, préemption de tâche). Notez que le <a href="#graph"><strong>graphe</strong></a> lui-même n'est pas inclus dans un point de contrôle.</p>
<p><a name="class"></a>
</p><h2 class="hide-from-toc"> classe (class)</h2><p></p>
<p>Un des ensembles de valeurs cibles énumérées pour une étiquette. Par exemple, dans un modèle de <a href="#binary_classification"><strong>classification binaire</strong></a> de détection du spam, les deux classes sont <em>spam</em> et <em>non-spam</em>.  Dans un modèle de <a href="#multi_class_classification"><strong>classification à classes multiples</strong></a> qui identifie les races de chiens, les classes peuvent être <em>caniche</em>, <em>beagle</em>, <em>carlin</em>, etc.</p>
<p><a name="class_imbalanced_data_set"></a>
</p><h2 class="hide-from-toc"> ensemble de données avec déséquilibre des classes (class-imbalanced data set)</h2><p></p>
<p>Problème de <a href="#binary_classification"><strong>classification binaire</strong></a> dans lequel les fréquences des <a href="#label"><strong>étiquettes</strong></a> des deux classes sont significativement différentes.  Par exemple, un ensemble de données de maladie dans lequel 0,0001 des exemples ont des étiquettes positives et 0,9999 ont des étiquettes négatives est un problème de déséquilibre des classes. Par contre, une prédiction de match de football dans laquelle 0,51 des exemples étiquettent une équipe comme gagnante et 0,49 étiquettent l'autre équipe comme gagnante <em>n'est pas</em> un problème avec un déséquilibre des classes.</p>
<p><a name="classification_model"></a>
</p><h2 class="hide-from-toc"> modèle de classification (classification model)</h2><p></p>
<p>Type de modèle de machine learning permettant de différencier deux classes discrètes ou plus. Par exemple, un modèle de classification par traitement du langage naturel pourrait déterminer si une phrase en entrée est en français, en espagnol ou en italien. À comparer au <a href="#regression_model"><strong>modèle de régression</strong></a>.</p>
<p><a name="classification_threshold"></a>
</p><h2 class="hide-from-toc"> seuil de classification (classification threshold)</h2><p></p>
<p>Critère de valeur scalaire appliqué au score d'un modèle dans le but de séparer la <a href="#positive_class"><strong>classe positive</strong></a> de la <a href="#negative_class"><strong>classe négative</strong></a>.  Utilisé pour mettre en correspondance les résultats de la <a href="#logistic_regression"><strong>régression logistique</strong></a> et la <a href="#binary_classification"><strong>classification binaire</strong></a>. Supposons un modèle de régression logistique qui détermine la probabilité qu'un message donné soit du spam. Si le seuil de classification est de 0,9, les valeurs de la régression logistique supérieures à 0,9 sont classées comme <em>spam</em>, et celles inférieures comme <em>non spam</em>.</p>
<p><a name="clustering"></a>
</p><h2 class="hide-from-toc">clustering</h2><p></p>
<p>Groupement d'<a href="#example"><strong>exemples</strong></a> similaires, en particulier lors d'<a href="#unsupervised_machine_learning"><strong>un apprentissage non supervisé</strong></a>. Une fois tous les exemples groupés, une personne peut éventuellement attribuer un sens à chaque cluster.</p>
<p>Il existe de nombreux algorithmes de clustering.  Par exemple, l'algorithme <a href="#k-means"><strong>k-moyennes</strong></a> groupe des exemples en fonction de leur proximité avec un <a href="#centroid"><strong>centroïde</strong></a>, comme dans le diagramme suivant :</p>
<p>
<img src="/machine-learning/glossary/images/Cluster.svg">
</p>

<p>Un chercheur pourrait alors examiner les clusters et, par exemple, étiqueter le cluster 1 en tant qu'"arbres nains" et le cluster 2 en tant qu'"arbres de taille normale".</p>
<p>Autre exemple, celui d'un algorithme de clustering basé sur la distance entre un exemple et un point central, illustré comme suit :</p>
<p>
<img src="/machine-learning/glossary/images/RingCluster.svg">
</p>

<p><a name="collaborative_filtering"></a>
</p><h2 class="hide-from-toc"> filtrage collaboratif (collaborative filtering)</h2><p></p>
<p>Réalisation de prédictions sur les centres d'intérêt d'un utilisateur reposant sur les centres d'intérêt de nombreux autres utilisateurs.  Le filtrage collaboratif est souvent utilisé dans les systèmes de recommandation.</p>
<p><a name="confusion_matrix"></a>
</p><h2 class="hide-from-toc"> matrice de confusion (confusion matrix)</h2><p></p>
<p>Table NxN qui résume la réussite des prédictions d'un <a href="#classification_model"><strong>modèle de classification</strong></a>, c'est-à-dire la corrélation entre les étiquettes et les classifications du modèle. L'un des axes d'une matrice de confusion est l'étiquette prédite par le modèle, et l'autre l'étiquette réelle. N correspond au nombre de classes. Dans un problème de <a href="#binary_classification"><strong>classification binaire</strong></a>, N=2. Voici un exemple de matrice de confusion pour un problème de classification binaire :</p>
<table>
<thead>
<tr>
<th></th>
<th>Tumeur (prédiction)</th>
<th>Pas de tumeur (prédiction)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tumeur (réel)</td>
<td>18</td>
<td>1</td>
</tr>
<tr>
<td>Pas de tumeur (réel)</td>
<td>6</td>
<td>452</td>
</tr>
</tbody>
</table>
<p>La matrice de confusion ci-dessus montre que pour les 19 échantillons qui étaient réellement des tumeurs, le modèle a correctement classé 18 d'entre eux comme tumeurs (18 vrais positifs) et incorrectement classé 1 comme n'ayant pas de tumeur (1 faux négatif). De même, parmi les 458 échantillons sans tumeur, 452 ont été correctement classés (452 vrais négatifs) et 6 ont été incorrectement classés (6 faux positifs).</p>
<p>La matrice de confusion relative à un problème de classification à classes multiples peut vous aider à déterminer les schémas d'erreur. Par exemple, une matrice de confusion peut révéler qu'un modèle entraîné à reconnaître les chiffres écrits à la main tend à prédire de façon erronée 9 à la place de 4, ou 1 au lieu de 7.</p>
<p>Les matrices de confusion contiennent suffisamment d'informations pour calculer diverses statistiques de performance, notamment la <a href="#precision"><strong>précision</strong></a> et le <a href="#recall"><strong>rappel</strong></a>.</p>
<p><a name="continuous_feature"></a>
</p><h2 class="hide-from-toc"> caractéristique continue (continuous feature)</h2><p></p>
<p>Caractéristique à virgule flottante avec une plage infinie de valeurs possibles.
À comparer à la <a href="#discrete_feature"><strong>caractéristique discrète</strong></a>.</p>
<p><a name="convergence"></a>
</p><h2 class="hide-from-toc"> convergence</h2><p></p>
<p>Désigne familièrement un état atteint pendant l'apprentissage, dans lequel la <a href="#loss"><strong>perte</strong></a> d'apprentissage et la perte de validation varient peu ou pas du tout entre chaque itération, passé un certain nombre d'itérations. Autrement dit, un modèle atteint la convergence lorsque la poursuite de l'apprentissage sur les données actuelles n'améliore pas le modèle. Dans le deep learning, les valeurs de perte restent parfois constantes ou presque pendant de nombreuses itérations avant de finalement diminuer, faisant croire à tort, temporairement, que la convergence a été atteinte.</p>
<p>Voir aussi <a href="#early_stopping"><strong>arrêt prématuré</strong></a>.</p>
<p>Voir aussi le livre de Stephen Boyd et Lieven Vandenberghe, <a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Convex Optimization</a> (en anglais).</p>
<p><a name="convex_function"></a>
</p><h2 class="hide-from-toc"> fonction convexe (convex function)</h2><p></p>
<p>Fonction dans laquelle la région au-dessus du graphique est un <a href="#convex_set"><strong>ensemble convexe</strong></a>.  Classiquement, une fonction convexe est en forme de <strong>U</strong>.  Par exemple, les fonctions suivantes sont toutes des fonctions convexes :</p>
<p>
<img src="/machine-learning/glossary/images/convex_functions.png" height="300" alt="Une fonction convexe typique est en U."/>
</p>

<p>À titre de comparaison, la fonction suivante n'est pas convexe.  Notez comment la région au-dessus du graphique diffère d'un ensemble convexe :</p>
<p>
<img src="/machine-learning/glossary/images/nonconvex_function.svg">
</p>

<p>Une <strong>fonction strictement convexe</strong> possède exactement un minimum local, qui est également le minimum global. Les fonctions classiques en U sont des fonctions strictement convexes.  Ce n'est pas le cas de certaines fonctions convexes, comme les droites.</p>
<p>De nombreuses <a href="#loss_functions"><strong>fonctions de perte</strong></a> courantes, telles que les fonctions suivantes, sont convexes :</p>
<ul>
<li><a href="#L2_loss"><strong>Perte L<sub>2</sub></strong></a></li>
<li><a href="#Log_Loss"><strong>Perte logistique</strong></a></li>
<li><a href="#L1_regularization"><strong>Régularisation L<sub>1</sub></strong></a></li>
<li><a href="#L2_regularization"><strong>Régularisation L<sub>2</sub></strong></a></li>
</ul>
<p>Dans de nombreux cas de <a href="#gradient_descent"><strong>descente de gradient</strong></a>, on peut être certain de trouver un point proche du minimum d'une fonction strictement convexe.  De même, dans de nombreux cas de <a href="#SGD"><strong>descente de gradient stochastique</strong></a>, la probabilité est forte de trouver un point proche du minimum d'une fonction strictement convexe, bien que cela ne soit pas garanti pour autant.</p>
<p>La somme de deux fonctions convexes (par exemple, perte L<sub>2</sub> + régularisation L<sub>1</sub>) est une fonction convexe.</p>
<p>Les <a href="#deep_model"><strong>modèles profonds</strong></a> ne sont jamais des fonctions convexes.
Il est à noter que les algorithmes conçus pour l'<a href="#convex_optimization"><strong>optimisation convexe</strong></a> tendent de toute façon à trouver des solutions raisonnablement satisfaisantes pour les réseaux profonds, même s'il n'est pas certain que ces solutions soient des minimums globaux.</p>
<p><a name="convex_optimization"></a>
</p><h2 class="hide-from-toc">optimisation convexe (convex optimization)</h2><p></p>
<p>Processus consistant à utiliser des techniques mathématiques telles que la <a href="#gradient_descent"><strong>descente de gradient</strong></a> pour déterminer le minimum d'une <a href="#convex_function"><strong>fonction convexe</strong></a>.
Dans le domaine du machine learning, de nombreuses études ont cherché à exprimer divers problèmes sous la forme de problèmes d'optimisation convexe pour les résoudre plus efficacement.</p>
<p>Pour des informations détaillées, voir le livre de Stephen Boyd et Lieven Vandenberghe, <a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Convex Optimization</a> (en anglais).</p>
<p><a name="convex_set"></a>
</p><h2 class="hide-from-toc">ensemble convexe (convex set)</h2><p></p>
<p>Sous-ensemble de l'espace euclidien caractérisé par le fait qu'une ligne tracée entre deux points quelconques du sous-ensemble est entièrement incluse dans le sous-ensemble.  Par exemple, les deux formes suivantes sont des ensembles convexes :</p>
<p>
<img src="/machine-learning/glossary/images/convex_set.png" alt="Un rectangle et une demi-ellipse sont tous deux des ensembles convexes."/>
</p>

<p>À titre de comparaison, les deux formes suivantes ne sont pas des ensembles convexes :</p>
<p>
<img src="/machine-learning/glossary/images/nonconvex_set.png" alt="Un graphique à secteurs dont il manque un secteur et un feu d&#39;artifice sont tous deux des ensembles non convexes."/>
</p>

<p><a name="convolution"></a>
</p><h2 class="hide-from-toc">convolution</h2><p></p>
<p>En mathématiques, désigne dans le langage courant un mélange de deux fonctions. Dans le machine learning, une convolution mélange le filtre convolutif et la matrice d'entrée pour entraîner les pondérations.</p>
<p>Dans le machine learning, le terme de "convolution" est fréquemment un raccourci langagier pour désigner l'<a href="#convolutional_operation"><strong>opération convolutive</strong></a> ou la <a href="#convolutional_layer"><strong>couche convolutive</strong></a>.</p>
<p>Sans convolution, un algorithme de machine learning devrait apprendre une pondération différente pour chaque cellule d'un grand Tensor.  Par exemple, un algorithme de machine learning dont l'apprentissage s'effectue sur des images de 2K x 2K serait forcé de trouver 4 millions de pondérations. Grâce aux convolutions, un algorithme de machine learning ne doit trouver des pondérations que pour chaque cellule du <a href="#convolutional_filter"><strong>filtre convolutif</strong></a>, ce qui réduit considérablement la mémoire nécessaire à l'entraînement du modèle.  Lorsque le filtre convolutif est appliqué, il est simplement répliqué entre les cellules de telle sorte que chacune d'entre elles est multipliée par le filtre.</p>
<p><a name="convolutional_filter"></a>
</p><h2 class="hide-from-toc">filtre convolutif (convolutional filter)</h2><p></p>
<p>L'un des deux acteurs d'une <a href="#convolutional_operation"><strong>opération convolutive</strong></a>. L'autre acteur est une fraction d'une matrice d'entrée. Un filtre convolutif est une matrice de même <a href="#rank"><strong>rang</strong></a> que la matrice d'entrée, mais de forme plus petite.
Par exemple, dans le cas d'une matrice d'entrée de 28 x 28, le filtre pourrait être n'importe quelle matrice 2D de taille inférieure à 28 x 28.</p>
<p>Dans la retouche photographique, toutes les cellules d'un filtre convolutif sont généralement définies sur un motif constant de zéro et de un. Dans le machine learning, les filtres convolutifs sont généralement générés à partir de nombres aléatoires, puis le réseau entraîne les valeurs idéales.</p>
<p><a name="convolutional_layer"></a>
</p><h2 class="hide-from-toc">couche convolutive (convolutional layer)</h2><p></p>
<p>Couche d'un réseau de neurones profond dans laquelle un <a href="#convolutional_filter"><strong>filtre convolutif</strong></a> transfert une matrice d'entrée.  Par exemple, le <a href="#convolutional_filter"><strong>filtre convolutif</strong></a> 3 x 3 suivant :</p>
<p>
<img src="/machine-learning/glossary/images/ConvolutionalFilter33.svg">
</p>

<p>L'animation suivante montre une couche convolutive composée de 9 opérations convolutives impliquant la matrice d'entrée 5 x 5. Notez que chaque opération convolutive fonctionne sur une différente tranche 3 x 3 de la matrice d'entrée.
La matrice 3 x 3 résultante (à droite) est constituée des résultats des 9 opérations convolutives :</p>
<p>
<img src="/machine-learning/glossary/images/AnimatedConvolution.gif"/>
</p>

<p><a name="convolutional_neural_network"></a>
</p><h2 class="hide-from-toc">réseau de neurones convolutif (convolutional neural network)</h2><p></p>
<p>Réseau de neurones dans lequel au moins une couche est une <a href="#convolutional_layer"><strong>couche convolutive</strong></a>. Un réseau de neurones convolutif typique consiste en une combinaison des couches suivantes :</p>
<ul>
<li>Couches convolutives</li>
<li>Couches de pooling</li>
<li>Couches denses</li>
</ul>
<p>Les réseaux de neurones convolutifs ont eu beaucoup de succès pour certains types de problèmes, notamment la reconnaissance d'images.</p>
<p><a name="convolutional_operation"></a>
</p><h2 class="hide-from-toc">opération convolutive (convolutional operation)</h2><p></p>
<p>L'opération mathématique en deux étapes suivante :</p>
<ol>
<li>Multiplication élément par élément du <a href="#convolutional_filter"><strong>filtre convolutif</strong></a> et d'une tranche d'une matrice d'entrée. La tranche de la matrice d'entrée est de même rang et de même taille que le filtre convolutif.</li>
<li>Somme de toutes les valeurs de la matrice de produits résultante.</li>
</ol>
<p>Soit, par exemple, la matrice d'entrée 5 x 5 suivante :</p>
<p>
<img src="/machine-learning/glossary/images/ConvolutionalLayerInputMatrix.svg">
</p>

<p>Soit, à présent, le filtre convolutif 2 x 2 suivant :</p>
<p>
<img src="/machine-learning/glossary/images/ConvolutionalLayerFilter.svg">
</p>

<p>Chaque opération convolutive implique une seule tranche 2 x 2 de la matrice d'entrée. Supposons que nous utilisions la tranche 2 x 2 en haut à gauche de la matrice d'entrée.  L'opération convolutive sur cette tranche est alors :</p>
<p>
<img src="/machine-learning/glossary/images/ConvolutionalLayerOperation.svg">
</p>

<p>Une <a href="#convolutional_layer"><strong>couche convolutive</strong></a> consiste en une série d'opérations convolutives, chacune agissant sur une tranche différente de la matrice d'entrée.</p>
<p><a name="cost"></a>
</p><h2 class="hide-from-toc"> coût (cost)</h2><p></p>
<p>Synonyme de <a href="#loss"><strong>perte</strong></a>.</p>
<p><a name="cross-entropy"></a>
</p><h2 class="hide-from-toc"> entropie croisée (cross-entropy)</h2><p></p>
<p>Généralisation de la <a href="#Log_Loss"><strong>perte logistique</strong></a> aux <a href="#multi-class"><strong>problèmes de classification à classes multiples</strong></a>. L'entropie croisée quantifie la différence entre deux distributions de probabilité.  Voir aussi <a href="#perplexity"><strong>perplexité</strong></a>.</p>
<p><a name="custom_estimator"></a>
</p><h2 class="hide-from-toc"> Estimator personnalisé (custom Estimator)</h2><p></p>
<p><a href="#Estimators"><strong>Estimator</strong></a> que vous écrivez vous-même en suivant <a href="https://www.tensorflow.org/extend/estimators">cette procédure</a>.</p>
<p>À comparer aux <a href="#pre-made_Estimator"><strong>Estimators prédéfinis</strong></a>.</p>

<p><a name="data_analysis"></a>
</p><h2 class="hide-from-toc"> analyse de données (data analysis)</h2><p></p>
<p>Procédure visant à comprendre des données en en étudiant les échantillons, les mesures et les visualisations. L'analyse de données peut s'avérer particulièrement utile à la réception d'un ensemble de données, avant la création du premier modèle. Elle est également cruciale pour interpréter les expériences et déboguer les problèmes affectant le système.</p>
<p><a name="DataFrame"></a>
</p><h2 class="hide-from-toc"> DataFrame</h2><p></p>
<p>Type de données populaire utilisé pour représenter des ensembles de données dans Pandas. Un DataFrame est analogue à un tableau. Chaque colonne du DataFrame porte un nom (un en-tête) et chaque ligne est identifiée par un nombre.</p>
<p><a name="data_set"></a>
</p><h2 class="hide-from-toc"> ensemble de données (data set)</h2><p></p>
<p>Un ensemble d'<a href="#example"><strong>exemples</strong></a>.</p>
<p><a name="dataset_API"></a>
</p><h2 class="hide-from-toc"> API Dataset (tf.data) (Dataset API (tf.data))</h2><p></p>
<p>API TensorFlow de haut niveau pour la lecture des données et leur transformation en une forme requise par un algorithme de machine learning. Un objet <code>tf.data.Dataset</code> représente une séquence d'éléments dans laquelle chaque élément contient un ou plusieurs <a href="#tensor"><strong>Tensors</strong></a>. Un objet <code>tf.data.Iterator</code> permet d'accéder aux éléments d'un <code>Dataset</code>.</p>
<p>Pour plus d'informations sur l'API Dataset, consultez la page <a href="https://www.tensorflow.org/programmers_guide/datasets">Importer des données</a> du guide du programmeur TensorFlow.</p>
<p><a name="decision_boundary"></a>
</p><h2 class="hide-from-toc"> frontière de décision (decision boundary)</h2><p></p>
<p>Séparateur entre les classes apprises par un modèle dans une <a href="#binary_classification"><strong>classe binaire</strong></a> ou dans les <a href="#multi-class"><strong>problèmes de classification à classes multiples</strong></a>. Par exemple, dans l'image suivante représentant un problème de classification binaire, la frontière de décision est la limite entre la classe orange et la classe bleue :</p>
<p>
<img src="/machine-learning/glossary/images/decision_boundary.png" alt="Limite bien définie entre deux classes."/>
</p>

<p><a name="deep_model"></a>
</p><h2 class="hide-from-toc"> modèle profond (deep model)</h2><p></p>
<p>Type de <a href="#neural_network"><strong>réseau de neurones</strong></a> contenant plusieurs <a href="#hidden_layer"><strong>couches cachées</strong></a>. Les modèles profonds reposent sur des non-linéarités qui peuvent être apprises.</p>
<p>À comparer au <a href="#wide_model"><strong>modèle large</strong></a>.</p>
</p><p><a name="dense_feature"></a>
</p><h2 class="hide-from-toc"> caractéristique dense (dense feature)</h2><p></p>
<p><a href="#feature"><strong>Caractéristique</strong></a> dont la plupart des valeurs sont différentes de zéro, généralement un <a href="#tensor"><strong>Tensor</strong></a> de valeurs à virgules flottantes. À comparer à la <a href="#sparse_features"><strong>caractéristique creuse</strong></a>.</p>
<p><a name="device"></a>
<p><a name="dense_layer"></a>
</p><h2 class="hide-from-toc"> couche dense (dense layer)</h2><p></p>
<p>Synonyme de <a href="#fully_connected_layer"><strong>couche entièrement connectée</strong></a>.</p>
</p><h2 class="hide-from-toc"> appareil (device)</h2><p></p>
<p>Catégorie de matériel pouvant exécuter une session TensorFlow, y compris les CPU, les GPU et les TPU.</p>
<p><a name="discrete_feature"></a>
</p><h2 class="hide-from-toc"> caractéristique discrète (discrete feature)</h2><p></p>
<p><a href="#feature"><strong>Caractéristique</strong></a> avec un ensemble fini de valeurs possibles. Par exemple, une caractéristique dont les valeurs peuvent être uniquement <em>animal</em>, <em>végétal</em> ou <em>minéral</em> est une caractéristique discrète (ou catégorique). À comparer à la <a href="#continuous_feature"><strong>caractéristique continue</strong></a>.</p>
<p><a name="dropout_regularization"></a>
</p><h2 class="hide-from-toc"> régularisation par abandon (dropout regularization)</h2><p></p>
<p>Forme de <a href="#regularization"><strong>régularisation</strong></a> utile dans l'apprentissage des <a href="#neural_network"><strong>réseaux de neurones</strong></a>. La régularisation par abandon consiste à supprimer de manière aléatoire un nombre fixe d'unités dans une couche du réseau pour un pas de gradient unique. Plus le nombre d'unités abandonnées est élevé, plus la régularisation est solide. Cette méthode est analogue à l'entraînement du modèle pour émuler un groupe exponentiellement large de réseaux plus petits. Pour plus d'informations, consultez l'article <a href="http://jmlr.org/papers/volume15/srivastava14a.old/srivastava14a.pdf">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a> (en anglais).</p>
<p><a name="dynamic_model"></a>
</p><h2 class="hide-from-toc"> modèle dynamique (dynamic model)</h2><p></p>
<p><a href="#model"><strong>Modèle</strong></a> entraîné en ligne et mis à jour en continu.  En d'autres termes, les données sont intégrées en continu dans le modèle.</p>

<p><a name="early_stopping"></a>
</p><h2 class="hide-from-toc"> arrêt prématuré (early stopping)</h2><p></p>
<p>Méthode de <a href="#regularization"><strong>régularisation</strong></a> qui implique de terminer l'entraînement du modèle <em>avant</em> que la perte de l'apprentissage cesse de baisser. Dans l'arrêt prématuré, l'entraînement du modèle est arrêté lorsque la perte d'un <a href="#validation_set"><strong>ensemble de données de validation</strong></a> commence à augmenter, c'est-à-dire lorsque les performances de <a href="#generalization"><strong>généralisation</strong></a> se dégradent.</p>
<p><a name="embeddings"></a>
</p><h2 class="hide-from-toc"> représentations vectorielles continues (embeddings)</h2><p></p>
<p>Caractéristique catégorique représentée sous la forme d'une caractéristique à valeur continue.
Généralement, une représentation vectorielle continue est la traduction d'un vecteur de grande dimension dans un espace de faible dimension. Vous pouvez par exemple représenter les mots d'une phrase en français de l'une des deux façons suivantes :</p>
<ul>
<li>Sous forme de <a href="#sparse_features"><strong>vecteur creux</strong></a> à un million d'éléments (grande dimension) dont tous les éléments sont des entiers.
    Chaque cellule du vecteur représente un mot français donné. La valeur d'une cellule représente le nombre de fois où ce mot apparaît dans une phrase.
    Étant donné qu'il est peu probable qu'une phrase française contienne plus de 50 mots, pratiquement toutes les cellules du vecteur contiennent la valeur 0. Les quelques cellules dont la valeur est différente de 0 contiennent un entier petit (généralement 1) qui représente le nombre d'occurrences de ce mot dans la phrase.</li>
<li>Sous forme de <a href="#dense_feature"><strong>vecteur dense</strong></a> à plusieurs centaines d'éléments (faible dimension), dans lequel chaque élément contient une valeur à virgule flottante comprise entre 0 et 1.  C'est une représentation vectorielle continue.</li>
</ul>
<p>Dans TensorFlow, les représentations vectorielles continues sont entraînées par <a href="#backpropagation"><strong>rétropropagation</strong></a> de la <a href="#loss"><strong>perte</strong></a>, comme n'importe quel autre paramètre d'un <a href="#neural_network"><strong>réseau de neurones</strong></a>.</p>
<p><a name="ERM"></a>
</p><h2 class="hide-from-toc"> minimisation du risque empirique (ERM) (empirical risk minimization (ERM))</h2><p></p>
<p>Sélection de la fonction qui minimise la perte pour l'ensemble d'apprentissage. À comparer à la <a href="#SRM"><strong>minimisation du risque structurel</strong></a>.</p>
<p><a name="ensemble"></a>
</p><h2 class="hide-from-toc"> groupe (ensemble)</h2><p></p>
<p>Fusion des prédictions de plusieurs <a href="#model"><strong>modèles</strong></a>. Vous pouvez créer un groupe de l'une des manières suivantes :</p>
<ul>
<li>À l'aide de différentes initialisations</li>
<li>À l'aide de différents <a href="#hyperparameter"><strong>hyperparamètres</strong></a></li>
<li>À l'aide de différentes structures globales</li>
</ul>
<p>Les modèles <a href="https://www.tensorflow.org/tutorials/wide_and_deep">profonds et larges</a> sont des types de groupes.
</p><p><a name="epoch"></a>
</p><h2 class="hide-from-toc"> itération (epoch)</h2><p></p>
<p>Cycle d'apprentissage complet sur l'intégralité de l'ensemble de données de manière à ce que chaque exemple ait été vu une fois.  Une itération représente ainsi <code>N</code>/<a href="#batch_size"><strong>taille du lot</strong></a> <a href="#iteration"><strong>itérations</strong></a> d'apprentissage, où <code>N</code> est le nombre total d'exemples.</p>
<p><a name="Estimators"></a>
</p><h2 class="hide-from-toc"> Estimator</h2><p></p>
<p>Instance de la classe <code>tf.Estimator</code>, qui encapsule la logique de création d'un graphique TensorFlow et exécute une session TensorFlow. Vous pouvez créer vos propres <a href="#custom_estimator"><strong>Estimators personnalisés</strong></a> (<a href="https://www.tensorflow.org/extend/estimators">comme décrit ici</a>) ou instancier des <a href="#pre-made_Estimator"><strong>Estimators prédéfinis</strong></a> créés par d'autres.</p>
<p><a name="example"></a>
</p><h2 class="hide-from-toc"> exemple (example)</h2><p></p>
<p>Ligne d'un ensemble de données. Un exemple contient une ou plusieurs <a href="#feature"><strong>caractéristiques</strong></a>, et éventuellement une <a href="#label"><strong>étiquette</strong></a>. Voir aussi <a href="#labeled_example"><strong>Exemple étiqueté</strong></a> et <a href="#unlabeled_example"><strong>Exemple sans étiquette</strong></a>.</p>

<p><a name="FN"></a>
</p><h2 class="hide-from-toc"> faux négatif (FN) (false negative (FN))</h2><p></p>
<p>Exemple dans lequel le modèle a prédit à tort la <a href="#negative_class"><strong>classe négative</strong></a>. Par exemple, le modèle a déduit qu'un e-mail particulier n'était pas du spam (classe négative), alors que c'était en réalité bien un courrier indésirable.</p>
<p><a name="false_positive"></a>
</p><h2 class="hide-from-toc"> faux positif (FP) (false positive (FP))</h2><p></p>
<p>Exemple dans lequel le modèle a prédit à tort la <a href="#positive_class"><strong>classe positive</strong></a>. Par exemple, le modèle a déduit qu'un e-mail particulier était du spam (classe positive), alors qu'en réalité ce n'était pas un courrier indésirable.</p>
<p><a name="FP_rate"></a>
</p><h2 class="hide-from-toc"> taux de faux positifs (taux de FP) (false positive rate (FP rate))</h2><p></p>
<p>L'abscisse d'une <a href="#ROC"><strong>courbe ROC</strong></a>. Le taux de FP est défini ainsi :</p>
<div>
$$\text{Taux de faux positifs} =
\frac{\text{Faux positifs}}{\text{Faux positifs} + \text{Vrais négatifs}}$$
</div>

<p><a name="feature"></a>
</p><h2 class="hide-from-toc"> caractéristique (feature)</h2><p></p>
<p>Variable d'entrée utilisée pour effectuer des <a href="#prediction"><strong>prédictions</strong></a>.</p>
<p><a name="feature_columns"></a>
</p><h2 class="hide-from-toc"> colonne de caractéristiques (feature column) (tf.feature_column)</h2><p></p>
<p>Fonction qui indique comment un modèle doit interpréter une caractéristique particulière. Une liste qui collecte la sortie renvoyée par les appels à de telles fonctions est obligatoire pour tous les constructeurs <a href="#Estimators"><strong>Estimators</strong></a>.</p>
<p>Les fonctions <code>tf.feature_column</code> permettent aux modèles d'expérimenter facilement différentes représentations des caractéristiques d'entrée. Pour plus d'informations, reportez-vous au <a href="https://www.tensorflow.org/get_started/feature_columns">chapitre Colonnes de caractéristiques</a> du guide des programmeurs TensorFlow.</p>
<p>L'expression "colonne de caractéristiques" est propre à Google.
Elle est appelée "espace de noms" dans le système <a href="https://en.wikipedia.org/wiki/Vowpal_Wabbit">VW</a> (chez Yahoo/Microsoft), ou <a href="https://www.csie.ntu.edu.tw/~cjlin/libffm/">champ</a>.</p>
<p><a name="feature_cross"></a>
</p><h2 class="hide-from-toc"> croisement de caractéristiques (feature cross)</h2><p></p>
<p><a href="#synthetic_feature"><strong>Caractéristique synthétique</strong></a> formée en croisant différentes caractéristiques (en les multipliant ou en prenant leur produit cartésien). Le croisement de caractéristiques facilite la représentation des relations non linéaires.</p>
<p><a name="feature_engineering"></a>
</p><h2 class="hide-from-toc"> extraction de caractéristiques (feature engineering)</h2><p></p>
<p>Processus consistant à déterminer les <a href="#feature"><strong>caractéristiques</strong></a> susceptibles d'être utiles pour entraîner un modèle, et à convertir les données brutes des fichiers journaux et d'autres sources en ces caractéristiques. Dans TensorFlow, l'extraction de caractéristiques implique souvent de convertir les entrées des fichiers journaux bruts en Protocol Buffers <a href="#tf.Example"><strong>tf.Example</strong></a>.  Voir aussi <a href="https://github.com/tensorflow/transform">tf.Transform</a>.</p>
<p>L'extraction de caractéristiques est parfois appelée <strong>découverte de caractéristiques</strong>.</p>
<p><a name="feature_set"></a>
</p><h2 class="hide-from-toc"> ensemble de caractéristiques (feature set)</h2><p></p>
<p>Groupe des <a href="#feature"><strong>caractéristiques</strong></a> utilisées pour l'entraînement de votre modèle de machine learning.
Par exemple, un ensemble de caractéristiques simple pour un modèle de prédiction de la valeur immobilière peut inclure le code postal, la taille du logement et l'état du logement.</p>
<p><a name="feature_spec"></a>
</p><h2 class="hide-from-toc"> spécifications des caractéristiques (feature spec)</h2><p></p>
<p>Description des informations requises pour extraire les données des <a href="#feature"><strong>caractéristiques</strong></a> contenues dans le Protocol Buffer <a href="#tf.Example"><strong>tf.Example</strong></a>. Celui-ci étant un simple conteneur de données, vous devez spécifier les éléments suivants :</p>
<ul>
<li>Données à extraire (c'est-à-dire, les clés des caractéristiques)</li>
<li>Type de données (par exemple, flottant ou entier)</li>
<li>Longueur (fixe ou variable)</li>
</ul>
<p>L'<a href="#Estimators"><strong>API Estimator</strong></a> permet de générer les spécifications des caractéristiques à partir d'une liste de <a href="#feature_columns"><strong>FeatureColumns</strong></a>.</p>
<p><a name="few-shot_learning"></a>
</p><h2 class="hide-from-toc"> apprentissage few-shot (few-shot learning)</h2><p></p>
<p>Approche du machine learning, souvent utilisée pour la classification d'objets, conçue pour apprendre des classificateurs efficaces à partir d'un petit nombre d'exemples d'apprentissage.</p>
<p>Voir aussi <a href="#one-shot_learning"><strong>apprentissage one-shot</strong></a>.</p>
<p><a name="full_softmax"></a>
</p><h2 class="hide-from-toc"> softmax complet (full softmax)</h2><p></p>
<p>Voir <a href="#softmax"><strong>softmax</strong></a>. À comparer à l'<a href="#candidate_sampling"><strong>échantillonnage de candidats</strong></a>.</p>
<p><a name="fully_connected_layer"></a>
</p><h2 class="hide-from-toc"> couche entièrement connectée (fully connected layer)</h2><p></p>
<p><a href="#hidden_layer"><strong>Couche cachée</strong></a> dans laquelle chaque <a href="#node"><strong>nœud</strong></a> est connecté à <em>chaque</em> nœud de la couche cachée suivante.</p>
<p>Les couches entièrement connectées sont également appelées <a href="#dense_layer"><strong>couches denses</strong></a>.</p>

</p><p><a name="generalization"></a>
</p><h2 class="hide-from-toc"> généralisation (generalization)</h2><p></p>
<p>Fait référence à la capacité du modèle à effectuer des prédictions correctes pour des données nouvelles, qui n'ont encore jamais été vues, plutôt que pour les données utilisées pour l'entraînement du modèle.</p>
<p><a name="generalized_linear_model"></a>
</p><h2 class="hide-from-toc"> modèle linéaire généralisé (generalized linear model)</h2><p></p>
<p>Généralisation des modèles de <a href="#least_squares_regression"><strong>régression des moindres carrés</strong></a>, qui sont basés sur le <a href="https://en.wikipedia.org/wiki/Gaussian_noise">bruit gaussien</a>, à d'autres types de modèles basés sur d'autres types de bruit, par exemple le <a href="https://en.wikipedia.org/wiki/Shot_noise">bruit de grenaille</a> ou le bruit catégorique. Exemples de modèles linéaires généralisés :</p>
<ul>
<li><a href="#logistic_regression"><strong>Régression logistique</strong></a></li>
<li>Régression à classes multiples</li>
<li>Régression des moindres carrés</li>
</ul>
<p>Les paramètres d'un modèle linéaire généralisé peuvent être déterminés via une <a href="https://en.wikipedia.org/wiki/Convex_optimization">optimisation convexe</a>.</p>
<p>Les modèles linéaires généralisés présentent les propriétés suivantes :</p>
<ul>
<li>La prédiction moyenne du modèle de régression des moindres carrés optimal est égale à l'étiquette moyenne des données d'apprentissage.</li>
<li>La probabilité moyenne prédite par le modèle de régression logistique optimal est égale à l'étiquette moyenne des données d'apprentissage.</li>
</ul>
<p>La puissance d'un modèle linéaire généralisé est limitée par les caractéristiques de celui-ci. Contrairement à un modèle profond, un modèle généralisé ne peut pas "apprendre de nouvelles caractéristiques".</p>
<p><a name="gradient"></a>
</p><h2 class="hide-from-toc"> gradient</h2><p></p>
<p>Vecteur des <a href="#partial_derivative"><strong>dérivées partielles</strong></a> calculées pour l'ensemble des variables indépendantes.  Dans le machine learning, le gradient correspond au vecteur des dérivées partielles de la fonction du modèle.  Le gradient indique toujours la direction de la croissance maximale.</p>
<p><a name="gradient_clipping"></a>
</p><h2 class="hide-from-toc"> bornement de la norme du gradient (gradient clipping)</h2><p></p>
<p>Valeurs du bornement de la norme du <a href="#gradient"><strong>gradient</strong></a> avant leur application. Le bornement de la norme du gradient aide à assurer la stabilité numérique et empêche l'<a href="http://www.cs.toronto.edu/~rgrosse/courses/csc321_2017/readings/L15%20Exploding%20and%20Vanishing%20Gradients.pdf">explosion des gradients</a>.</p>
<p><a name="gradient_descent"></a>
</p><h2 class="hide-from-toc"> descente de gradient (gradient descent)</h2><p></p>
<p>Technique de minimisation de la <a href="#loss"><strong>perte</strong></a> en calculant les gradients de la perte pour les paramètres du modèle, en fonction des données d'apprentissage.
La descente de gradient ajuste de manière itérative les paramètres afin de trouver progressivement la meilleure combinaison de <a href="#weight"><strong>pondérations</strong></a> et de biais pour minimiser la perte.</p>
<p><a name="graph"></a>
</p><h2 class="hide-from-toc"> graphe (graph)</h2><p></p>
<p>Dans TensorFlow, les spécifications du calcul. Les nœuds du graphe représentent des opérations. Les bords sont orientés et représentent le passage du résultat d'une opération (un <a href="https://www.tensorflow.org/api_docs/python/tf/Tensor">Tensor</a>) en tant qu'opérande vers une autre opération. Pour visualiser un graphe, utilisez <a href="#TensorBoard"><strong>TensorBoard</strong></a>.</p>

<p><a name="heuristic"></a>
</p><h2 class="hide-from-toc"> heuristique (heuristic)</h2><p></p>
<p>Solution pratique et non optimale à un problème, mais qui est suffisante pour avancer ou pour tirer des leçons.</p>
<p><a name="hidden_layer"></a>
</p><h2 class="hide-from-toc"> couche cachée (hidden layer)</h2><p></p>
<p>Couche synthétique d'un <a href="#neural_network"><strong>réseau de neurones</strong></a> entre la <a href="#input_layer"><strong>couche d'entrée</strong></a> (c'est-à-dire, les caractéristiques) et la <a href="#output_layer"><strong>couche de sortie</strong></a> (la prédiction). Un réseau de neurones se compose d'une ou plusieurs couches cachées.</p>
<p><a name="hinge-loss"></a>
</p><h2 class="hide-from-toc"> marge maximale (hinge loss)</h2><p></p>
<p>Famille de fonctions de <a href="#loss"><strong>perte</strong></a> pour la <a href="#classification_model"><strong>classification</strong></a>, conçue pour déterminer la <a href="#decision_boundary"><strong>frontière de décision</strong></a> la plus éloignée possible de chaque exemple d'apprentissage, afin de maximiser la marge entre les exemples et la frontière.
Les <a href="#KSVMs"><strong>KSVM</strong></a> utilisent la marge maximale (ou une fonction associée, par exemple le carré de la marge maximale). Dans le cas de la classification binaire, la fonction de marge maximale est définie ainsi :</p>
<div>
$$\text{perte} = \text{max.}(0, 1 - (y' * y))$$
</div>

<p>Où <em>y'</em> est la sortie brute du modèle du classificateur :</p>
<div>
$$y' = b + w_1x_1 + w_2x_2 + … w_nx_n$$
</div>

<p>et <em>y</em> est l'étiquette réelle, soit -1, soit +1.</p>
<p>Par conséquent, le graphique de la marge maximale en fonction de (y * y') est de la forme suivante :</p>
<p>
<img src="/machine-learning/glossary/images/hinge-loss.svg">
</p>

<p><a name="holdout_data"></a>
</p><h2 class="hide-from-toc"> données exclues (holdout data)</h2><p></p>
<p><a href="#example"><strong>Exemples</strong></a> intentionnellement non utilisés ("exclus") pendant l'apprentissage.
L'<a href="#validation_set"><strong>ensemble de données de validation</strong></a> et l'<a href="#test_set"><strong>ensemble de données d'évaluation</strong></a> sont des exemples de données exclues. Les données exclues aident à évaluer la capacité de votre modèle à être généralisé à des données autres que celles utilisées pour l'apprentissage. La perte d'un ensemble de données non vues jusqu'à présent est estimée plus précisément par la perte de l'ensemble de données exclues que par celui de l'ensemble d'apprentissage.</p>
<p><a name="hyperparameter"></a>
</p><h2 class="hide-from-toc"> hyperparamètre (hyperparameter)</h2><p></p>
<p>Les paramètres que vous
réglez pendant les exécutions successives de l'entraînement du modèle. Le <a href="#learning_rate"><strong>taux d'apprentissage</strong></a>, par exemple, est un hyperparamètre.</p>
<p>À comparer aux <a href="#parameter"><strong>paramètres</strong></a>.</p>
<p><a name="hyperplane"></a>
</p><h2 class="hide-from-toc"> hyperplan (hyperplane)</h2><p></p>
<p>Frontière qui sépare un espace en deux sous-espaces.  Par exemple, une ligne est un hyperplan en deux dimensions, et un plan est un hyperplan en trois dimensions.
Plus généralement dans le machine learning, un hyperplan est la frontière qui sépare un espace de grande dimension.  Les <a href="#KSVMs"><strong>machines à vecteurs de support à noyau</strong></a> utilisent les hyperplans pour séparer les classes positives et négatives, souvent dans un espace de très grande dimension.</p>

<p><a name="iid"></a>
</p><h2 class="hide-from-toc">variables indépendantes et identiquement distribuées (variables iid) (independently and identically distributed (i.i.d))</h2><p></p>
<p>Données tirées d'une distribution qui ne change pas et où chaque valeur tirée ne dépend pas des valeurs précédemment tirées. Une variable iid
est le <a href="https://en.wikipedia.org/wiki/Ideal_gas">gaz parfait</a> du machine learning : c'est une construction mathématique utile qui ne se rencontre quasiment jamais à l'identique dans le monde réel. Par exemple, la distribution des visiteurs d'une page Web peut être une variable idd sur une courte période, c'est-à-dire que la distribution ne change pas pendant cette période et que la visite d'un internaute est généralement indépendante de la visite d'un autre. Toutefois, si vous allongez cette période, des différences saisonnières au niveau des visiteurs de la page Web peuvent apparaître.</p>
<p><a name="inference"></a>
</p><h2 class="hide-from-toc"> inférence (inference)</h2><p></p>
<p>Dans le machine learning, désigne généralement l'application du modèle entraîné à des <a href="#unlabeled_example"><strong>exemples sans étiquette</strong></a> pour effectuer des prédictions.
En statistiques, l'inférence désigne le processus d'ajustement des paramètres d'une distribution conditionnée à certaines données observées. Voir l'<a href="https://en.wikipedia.org/wiki/Statistical_inference">article Wikipédia sur l'inférence statistique</a>.</p>
<p><a name="input_function"></a>
</p><h2 class="hide-from-toc"> fonction d'entrée (input function)</h2><p></p>
<p>Dans TensorFlow, fonction qui renvoie des données d'entrée à la méthode d'apprentissage, d'évaluation ou de prédiction d'un <a href="#Estimators"><strong>Estimator</strong></a>.  Par exemple, la fonction d'entrée d'apprentissage renvoie un <a href="#batch"><strong>lot</strong></a> de caractéristiques et d'étiquettes depuis l'<a href="#training_set"><strong>ensemble d'apprentissage</strong></a>.</p>
<p><a name="input_layer"></a>
</p><h2 class="hide-from-toc"> couche d'entrée (input layer)</h2><p></p>
<p>Première couche (ou couche recevant les données d'entrée) d'un <a href="#neural_network"><strong>réseau de neurones</strong></a>.</p>
<p><a name="instance"></a>
</p><h2 class="hide-from-toc"> instance</h2><p></p>
<p>Synonyme d'<a href="#example"><strong>exemple</strong></a>.</p>
<p><a name="interpretability"></a>
</p><h2 class="hide-from-toc"> interprétabilité (interpretability)</h2><p></p>
<p>Facilité à expliquer les prédictions du modèle. Les modèles profonds sont souvent non interprétables, c'est-à-dire que les différentes couches d'un modèle profond sont difficiles à déchiffrer. En revanche, les modèles de régression linéaire et les <a href="#wide_model"><strong>modèles larges</strong></a> sont généralement bien plus interprétables.</p>
<p><a name="inter-rater_agreement"></a>
</p><h2 class="hide-from-toc"> accord inter-évaluateurs (inter-rater agreement)</h2><p></p>
<p>Mesure de la fréquence à laquelle différents évaluateurs humains sont d'accord lors de l'exécution d'une tâche.
Si les évaluateurs sont en désaccord, une amélioration des instructions peut être nécessaire.
Parfois également appelé <strong>accord inter-annotateurs</strong> ou <strong>fiabilité inter-évaluateurs</strong>.  Voir aussi le <a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">kappa de Cohen</a>, l'une des mesures de l'accord inter-évaluateurs les plus populaires.</p>
<p><a name="iteration"></a>
</p><h2 class="hide-from-toc"> itération (iteration)</h2><p></p>
<p>Mise à jour unique des pondérations d'un modèle pendant l'apprentissage.  Une itération consiste à calculer les gradients des paramètres en termes de perte sur un seul <a href="#batch"><strong>lot</strong></a> de données.</p>

<p><a name="k-means"></a>
</p><h2 class="hide-from-toc"> k-moyennes (k-means)</h2><p></p>
<p>Un algorithme de <a href="#clustering"><strong>clustering</strong></a> populaire qui regroupe des exemples dans l'apprentissage non supervisé. L'algorithme k-moyennes effectue les opérations suivantes :</p>
<ul>
<li>Détermination de manière itérative des meilleurs k points centraux (appelés <a href="#centroid"><strong>centroïdes</strong></a>).</li>
<li>Assignation de chaque exemple au centroïde le plus proche.  Les exemples les plus proches du même centroïde font partie du même groupe.</li>
</ul>
<p>L'algorithme k-moyennes choisit l'emplacement des centroïdes de manière à minimiser le <em>carré</em> cumulatif des distances entre chaque exemple et son centroïde le plus proche.</p>
<p>Supposons le graphe suivant représentant la taille de chiens en fonction de leur largeur :</p>
<p>
<img src="/machine-learning/glossary/images/DogDimensions.svg">
</p>

<p>Si k = 3, l'algorithme k-moyennes détermine trois centroïdes.  Chaque exemple est assigné à son centroïde le plus proche, ce qui donne trois groupes :</p>
<p>
<img src="/machine-learning/glossary/images/DogDimensionsKMeans.svg">
</p>

<p>Imaginez qu'un fabricant souhaite déterminer les tailles idéales de pulls pour chien petits, moyens et grands. Les trois centroïdes identifient la hauteur et la largeur moyennes de chaque chien du cluster correspondant. Ainsi, le fabricant devrait probablement baser les tailles de pull sur ces trois centroïdes.  Notez que le centroïde d'un cluster n'est généralement <em>pas</em> un exemple du cluster.</p>
<p>Les illustrations précédentes montrent les k-moyennes pour des exemples avec seulement deux caractéristiques (hauteur et largeur). Notez que les k-moyennes peuvent regrouper des exemples pour de nombreuses caractéristiques.</p>
<p><a name="k-median"></a>
</p><h2 class="hide-from-toc"> k-médiane (k-median)</h2><p></p>
<p>Algorithme de clustering étroitement lié à <a href="#k-means"><strong>k-moyennes</strong></a>. La différence pratique entre les deux est la suivante :</p>
<ul>
<li>Dans l'algorithme k-moyennes, les centroïdes sont déterminés en minimisant la somme des <em>carrés</em> de la distance entre un centroïde potentiel et chacun de ses exemples.</li>
<li>Dans l'algorithme k-médiane, les centroïdes sont déterminés en minimisant la somme de la distance entre un centroïde potentiel et chacun de ses exemples.</li>
</ul>
<p>Notez que la définition du terme "distance" est également différente :</p>
<ul>
<li>Dans l'algorithme k-moyenne, la notion de distance utilisée est la <a href="https://en.wikipedia.org/wiki/Euclidean_distance">distance euclidienne</a> entre un centroïde et un exemple.  Dans un espace à deux dimensions, la distance euclidienne revient à utiliser le théorème de Pythagore pour calculer l'hypoténuse.  Par exemple, la distance k-moyennes entre (2,2) et (5,-2) est :</li>
</ul>
<div>
$$
{\text{distance euclidienne}} = {\sqrt {(2-5)^2 + (2--2)^2}} = 5
$$
</div>

<ul>
<li>Dans l'algorithme k-médiane, la notion de distance utilisée est la <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">distance de Manhattan</a> entre le centroïde et un exemple.  Cette distance est la somme des deltas absolus dans chaque dimension.  Par exemple, la distance k-médiane entre (2,2) et (5,-2) est :</li>
</ul>
<div>
$$
{\text{distance de Manhattan}} = \lvert 2-5 \rvert + \lvert 2--2 \rvert = 7
$$
</div>

<p><a name="Keras"></a>
</p><h2 class="hide-from-toc"> Keras</h2><p></p>
<p>API de machine learning Python populaire. <a href="https://keras.io">Keras</a> s'exécute sur plusieurs cadres de deep learning, y compris TensorFlow, où il est disponible via <a href="https://www.tensorflow.org/api_docs/python/tf/keras"><strong>tf.keras</strong></a>.</p>
<p><a name="KSVMs"></a>
</p><h2 class="hide-from-toc">machines à vecteurs de support à noyau (KSVM) (Kernel Support Vector Machines (KSVMs))</h2><p></p>
<p>Algorithme de classification qui cherche à maximiser la marge entre les <a href="#positive_class"><strong>classes positives</strong></a> et les <a href="#negative_class"><strong>classes négatives</strong></a> en associant à chaque vecteur d'entrée un vecteur dans un espace de plus grande dimension.  Considérons par exemple un problème de classification dans lequel l'ensemble de données d'entrée se compose de cent caractéristiques. Afin de maximiser la marge entre les classes positives et négatives, un KVSM pourrait associer, en interne, chaque vecteur de caractéristiques à un vecteur dans un espace à un million de dimensions.  Les KSVM utilisent une fonction de perte appelée <a href="#hinge-loss">marge maximale</a>.</p>

<p><a name="L1_loss"></a>
</p><h2 class="hide-from-toc"> perte L<sub>1</sub> (L1 loss)</h2><p></p>
<p>Fonction de <a href="#loss"><strong>perte</strong></a> basée sur la valeur absolue de la différence entre les valeurs prédites par un modèle et les valeurs réelles des <a href="#label"><strong>étiquettes</strong></a>. La perte L<sub>1</sub> est moins sensible aux anomalies que la <a href="#squared_loss"><strong>perte L<sub>2</sub></strong></a>.</p>
<p><a name="L1_regularization"></a>
</p><h2 class="hide-from-toc"> régularisation L<sub>1</sub> (L1 regularization)</h2><p></p>
<p>Type de <a href="#regularization"><strong>régularisation</strong></a> qui pénalise les pondérations proportionnellement à la somme de leurs valeurs absolues. Dans les modèles reposant sur des <a href="#sparse_features"><strong>caractéristiques creuses</strong></a>, la régularisation L<sub>1</sub> aide à mettre à zéro les pondérations des caractéristiques peu ou pas pertinentes, ce qui a pour effet de supprimer celles-ci du modèle.
À comparer à la <a href="#L2_regularization"><strong>régularisation L<sub>2</sub></strong></a>.</p>
<p><a name="L2_loss"></a>
</p><h2 class="hide-from-toc"> perte L<sub>2</sub> (L2 loss)</h2><p></p>
<p>Voir <a href="#squared_loss"><strong>perte quadratique</strong></a>.</p>
<p><a name="L2_regularization"></a>
</p><h2 class="hide-from-toc"> régularisation L<sub>2</sub> (L2 regularization)</h2><p></p>
<p>Type de <a href="#regularization"><strong>régularisation</strong></a> qui pénalise les pondérations proportionnellement à la somme de leurs <em>carrés</em>.
La régularisation L<sub>2</sub> aide à rapprocher de zéro la pondération des anomalies (celles dont la valeur est très positive ou très négative), sans pour autant atteindre zéro.
(À comparer à la <a href="#L1_regularization"><strong>régularisation L1</strong></a>.)
La régularisation L<sub>2</sub> améliore toujours la généralisation des modèles linéaires.</p>
<p><a name="label"></a>
</p><h2 class="hide-from-toc"> étiquette (label)</h2><p></p>
<p>Dans l'apprentissage supervisé, "réponse" ou "résultat" d'un <a href="#example"><strong>exemple</strong></a>. Chaque exemple d'un ensemble de données étiqueté se compose d'au moins une caractéristique et d'une étiquette. Par exemple, les caractéristiques d'un ensemble de données sur des logements pourraient inclure le nombre de chambres, le nombre de salles de bain et l'âge du logement, et l'étiquette pourrait être le prix du logement.
Dans un ensemble de données de détection de spam, les caractéristiques pourraient être l'objet, l'expéditeur et le message lui-même, et l'étiquette serait probablement "spam" ou "non spam."</p>
<p><a name="labeled_example"></a>
</p><h2 class="hide-from-toc"> exemple étiqueté (labeled example)</h2><p></p>
<p>Exemple contenant des <a href="#feature"><strong>caractéristiques</strong></a> et une <a href="#label"><strong>étiquette</strong></a>. Dans l'apprentissage supervisé, les modèles sont entraînés avec des exemples étiquetés.</p>
<p><a name="lambda"></a>
</p><h2 class="hide-from-toc"> lambda</h2><p></p>
<p>Synonyme de <a href="#regularization_rate"><strong>taux de régularisation</strong></a>.</p>
<p>Ce terme recouvre de nombreux concepts. Ici, nous nous référons à sa définition dans le cadre de la <a href="#regularization"><strong>régularisation</strong></a>.</p>
<p><a name="layer"></a>
</p><h2 class="hide-from-toc"> couche (layer)</h2><p></p>
<p>Ensemble des <a href="#neuron"><strong>neurones</strong></a> d'un <a href="#neural_network"><strong>réseau de neurones</strong></a> qui traite un ensemble de caractéristiques d'entrée, ou le résultat de ces neurones.</p>
<p>Également une abstraction dans TensorFlow. Les couches sont des fonctions Python qui prennent des options de <a href="#tensor"><strong>Tensors</strong></a> et de configuration en entrée pour générer d'autres Tensors en sortie. Une fois les Tensors nécessaires créés, l'utilisateur peut convertir le résultat en un <a href="#Estimators"><strong>Estimator</strong></a> via une <a href="#model_function"><strong>fonction de modèle</strong></a>.</p>
<p><a name="layers_API"></a>
</p><h2 class="hide-from-toc"> API Layers (tf.layers) (Layers API (tf.layers))</h2><p></p>
<p>API TensorFlow pour la construction d'un réseau de neurones <a href="#deep_model"><strong>profond</strong></a> à partir de plusieurs couches. L'API Layers permet notamment de créer les types de <a href="#layer"><strong>couches</strong></a> suivants :</p>
<ul>
<li><code>tf.layers.Dense</code> pour une <a href="#fully_connected_layer"><strong>couche entièrement connectée</strong></a></li>
<li><code>tf.layers.Conv2D</code> pour une couche convolutive</li>
</ul>
<p>Lorsque vous écrivez un <a href="#custom_estimator"><strong>Estimator personnalisé</strong></a>, vous créez des objets Layers pour définir les caractéristiques de toutes les <a href="#hidden_layers"><strong>couches cachées</strong></a>.</p>
<p>L'API Layers respecte les conventions de l'API <a href="#Keras"><strong>Keras</strong></a> concernant les couches.
De ce fait, à part un préfixe différent, toutes les fonctions de l'API Layers ont des noms et des signatures identiques à ceux de leurs homologues dans l'API Keras pour les couches.</p>
<p><a name="learning_rate"></a>
</p><h2 class="hide-from-toc"> taux d'apprentissage (learning rate)</h2><p></p>
<p>Grandeur scalaire utilisée pour entraîner le modèle via la descente de gradient. À chaque itération, l'algorithme de <a href="#gradient_descent"><strong>descente de gradient</strong></a> multiplie le taux d'apprentissage par le gradient.  Le produit ainsi généré est appelé <strong>pas de gradient</strong>.</p>
<p>Le taux d'apprentissage est un <a href="#hyperparameter"><strong>hyperparamètre</strong></a> clé.</p>
<p><a name="least_squares_regression"></a>
</p><h2 class="hide-from-toc"> régression des moindres carrés (least squares regression)</h2><p></p>
<p>Modèle de régression linéaire entraîné en minimisant la <a href="#L2_loss"><strong>perte L<sub>2</sub></strong></a>.</p>
<p><a name="linear_regression"></a>
</p><h2 class="hide-from-toc"> régression linéaire (linear regression)</h2><p></p>
<p>Type de <a href="#regression_model"><strong>modèle de régression</strong></a> qui génère une valeur continue à partir d'une combinaison linéaire de caractéristiques d'entrée.</p>
<p><a name="logistic_regression"></a>
</p><h2 class="hide-from-toc"> régression logistique (logistic regression)</h2><p></p>
<p>Modèle qui génère une probabilité pour chaque valeur d'étiquette discrète possible dans les problèmes de classification en appliquant une <a href="#sigmoid_function"><strong>fonction sigmoïde</strong></a> à une prédiction linéaire. Bien que la régression logistique soit fréquemment utilisée dans les problèmes de <a href="#binary_classification"><strong>classification binaire</strong></a>, elle peut également être utilisée dans les problèmes de classification à <a href="#multi-class"><strong>classes multiples</strong></a> (auquel cas elle est appelée <strong>régression logistique à classes multiples</strong> ou <strong>régression multinomiale</strong>).</p>
<p><a name="logits"></a>
</p><h2 class="hide-from-toc"> fonctions logit (logits)</h2><p></p>
<p>Vecteur de prédictions brutes (non normalisées) généré par un modèle de classification, et qui est habituellement transmis à une fonction de normalisation.
Si le modèle résout un problème de classification à classes multiples, les fonctions logit sont généralement utilisées comme entrée de la <a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits_v2">fonction softmax</a>.
Celle-ci génère alors un vecteur de probabilités (normalisées) avec une valeur pour chaque classe possible.</p>
<p>De plus, les fonctions logit renvoient parfois à l'inverse par élément de la <a href="#sigmoid_function"><strong>fonction sigmoïde</strong></a>. Pour en savoir plus, consultez la page <a href="https://www.tensorflow.org/api_docs/python/tf/nn/sigmoid_cross_entropy_with_logits">tf.nn.sigmoid_cross_entropy_with_logits</a>.</p>
<p><a name="Log_Loss"></a>
</p><h2 class="hide-from-toc"> perte logistique (Log Loss)</h2><p></p>
<p>Fonction de <a href="#loss"><strong>perte</strong></a> utilisée dans la <a href="#logistic_regression"><strong>régression logistique</strong></a> binaire.</p>
<p><a name="log-odds"></a>
</p><h2 class="hide-from-toc"> logarithme de cote (log-odds)</h2><p></p>
<p>Logarithme des cotes d'un événement donné.</p>
<p>Si l'événement renvoie à une cote binaire, alors la <strong>cote</strong> renvoie au rapport entre la cote de réussite (p) et la cote d'échec (1-p).  Supposons qu'un événement donné ait une cote de réussite de 90 % et une cote d'échec de 10 %. Dans ce cas, les cotes sont calculées de la manière suivante :</p>
<div>
$$
{\text{cotes}} =
\frac{\text{p}} {\text{(1-p)}} =
\frac{.9} {.1} =
{\text{9}}
$$
</div>

<p>Le logarithme des cotes n'est rien d'autre, comme son nom l'indique, que le logarithme des cotes. Par convention, "logarithme" fait référence au logarithme naturel, mais il pourrait en fait être n'importe quelle base supérieure à 1.  Si l'on s'en tient à la convention, le logarithme des cotes de notre exemple est donc :</p>
<div>
$$
{\text{logarithme des cotes}} =
ln(9) ~= 2.2
$$
</div>

<p>Le logarithme des cotes est l'inverse de la <a href="#sigmoid_function"><strong>fonction sigmoïde</strong></a>.</p>
<p><a name="loss"></a>
</p><h2 class="hide-from-toc"> perte (loss)</h2><p></p>
<p>Mesure de l'écart entre les <a href="#prediction"><strong>prédictions</strong></a> d'un modèle et son <a href="#label"><strong>étiquette</strong></a>. Ou, de façon plus pessimiste, mesure de la médiocrité du modèle. Pour déterminer cette valeur, un modèle doit définir une fonction de perte. Par exemple, les modèles de régression linéaire utilisent généralement l'<a href="#MSE"><strong>erreur quadratique moyenne</strong></a> comme fonction de perte, tandis que les modèles de régression logistiques utilisent la <a href="#Log_Loss"><strong>perte logistique</strong></a>.</p>

<p><a name="machine_learning"></a>
</p><h2 class="hide-from-toc"> machine learning</h2><p></p>
<p>Programme ou système qui crée (entraîne) un modèle prédictif à partir de données d'entrée.
Le système utilise le modèle entraîné pour effectuer des prédictions utiles à partir de nouvelles données (jamais vues auparavant) issues de la même distribution que celle utilisée pour entraîner le modèle. Le machine learning (ou apprentissage automatique) désigne également la discipline qui traite de ces programmes ou systèmes.</p>
<p><a name="MSE"></a>
</p><h2 class="hide-from-toc"> erreur quadratique moyenne (MSE) (Mean Squared Error (MSE))</h2><p></p>
<p>Perte quadratique moyenne pour chaque exemple. La MSE est calculée en divisant la <a href="#squared_loss"><strong>perte quadratique</strong></a> par le nombre d'<a href="#example"><strong>exemples</strong></a>. Les valeurs que <a href="#TensorFlow_Playground"><strong>TensorFlow Playground</strong></a> affiche pour "Perte d'apprentissage" et "Perte de test" sont des MSE.</p>
<p><a name="metric"></a>
</p><h2 class="hide-from-toc"> statistique (metric)</h2><p></p>
<p>Nombre qui vous intéresse. Peut ou non être optimisé directement dans un système de machine learning. Une statistique que votre système tente d'optimiser est appelée <a href="#objective"><strong>objectif</strong></a>.</p>
<p><a name="metrics_API"></a>
</p><h2 class="hide-from-toc"> API Metrics (tf.metrics) (Metrics API (tf.metrics))</h2><p></p>
<p>API TensorFlow pour évaluer les modèles. Par exemple, <code>tf.metrics.accuracy</code> détermine la proportion d'exemples pour lesquels les prédictions du modèle coïncident avec les étiquettes. Lorsque vous écrivez un <a href="#custom_estimator"><strong>Estimator personnalisé</strong></a>, vous invoquez les fonctions de l'API Metrics pour spécifier la méthode d'évaluation de votre modèle.</p>
<p><a name="mini-batch"></a>
</p><h2 class="hide-from-toc"> mini-lot (mini-batch)</h2><p></p>
<p>Petit sous-ensemble, sélectionné aléatoirement, du lot complet d'<a href="#example"><strong>exemples</strong></a> exécutés simultanément dans une même itération d'apprentissage ou d'inférence. La <a href="#batch_size"><strong>taille de lot</strong></a> d'un mini-lot est généralement comprise entre 10 et 1 000. Il est bien plus efficace de calculer la perte pour un mini-lot que pour l'ensemble entier des données d'apprentissage.</p>
<p><a name="mini-batch_SGD"></a>
</p><h2 class="hide-from-toc"> descente de gradient stochastique par mini-lots (SGD) (mini-batch stochastic gradient descent (SGD))</h2><p></p>
<p>Algorithme de <a href="#gradient_descent"><strong>descente de gradient</strong></a> qui utilise des <a href="#mini-batch"><strong>mini-lots</strong></a>. En d'autres termes, la SGD par mini-lots estime le gradient à partir d'un petit sous-ensemble des données d'apprentissage. <a href="#SGD"><strong>Vanilla SGD</strong></a> utilise un mini-lot de taille 1.</p>
<p><a name="ML"></a>
</p><h2 class="hide-from-toc"> ML</h2><p></p>
<p>Abréviation de <a href="#machine_learning"><strong>machine learning</strong></a> (apprentissage automatique).</p>
<p><a name="model"></a>
</p><h2 class="hide-from-toc"> modèle (model)</h2><p></p>
<p>Représentation de ce qu'un système ML a appris à partir des données d'apprentissage.
Ce terme complexe peut avoir l'un des deux sens associés suivants :</p>
<ul>
<li>Graphe <a href="#TensorFlow"><strong>TensorFlow</strong></a> qui exprime la structure du calcul d'une prédiction</li>
<li>Pondérations et biais particuliers de ce graphe TensorFlow déterminés par <a href="#model_training"><strong>apprentissage</strong></a></li>
</ul>
<p><a name="model_function"></a>
</p><h2 class="hide-from-toc"> fonction de modèle (model function)</h2><p></p>
<p>Fonction dans un <a href="#Estimators"><strong>Estimator</strong></a> qui implémente l'entraînement, l'évaluation et l'inférence ML. Par exemple, la partie entraînement d'une fonction de modèle peut gérer des tâches telles que la définition de la topologie d'un réseau de neurones profond et l'identification de sa fonction d'<a href="#optimizer"><strong>optimiseur</strong></a>.
Lorsque vous utilisez des <a href="#pre-made_Estimator"><strong>Estimators prédéfinis</strong></a>, quelqu'un a déjà écrit la fonction de modèle pour vous.  Lorsque vous utilisez des <a href="#custom_estimator"><strong>Estimators personnalisés</strong></a>, vous devez écrire la fonction de modèle vous-même.</p>
<p>Pour en savoir plus sur l'écriture d'une fonction de modèle, consultez la page <a href="https://www.tensorflow.org/get_started/custom_estimators">Création d'Estimators personnalisés</a>.</p>
<p><a name="model_training"></a>
</p><h2 class="hide-from-toc"> entraînement de modèle (model training)</h2><p></p>
<p>Processus visant à déterminer le meilleur <a href="#model"><strong>modèle</strong></a>.</p>
<p><a name="Momentum"></a>
</p><h2 class="hide-from-toc"> Momentum</h2><p></p>
<p>Algorithme sophistiqué de descente de gradient dans lequel une étape d'apprentissage dépend non seulement de la dérivée de l'étape actuelle, mais aussi des dérivées des étapes qui l'ont immédiatement précédée. Momentum calcule une moyenne glissante pondérée exponentiellement des gradients au fil du temps, à l'instar du calcul du moment en physique.  Momentum permet parfois d'éviter à l'apprentissage de se retrouver bloqué à un minimum local.</p>
<p><a name="multi-class"></a>
</p><h2 class="hide-from-toc"> classification à classes multiples (multi-class classification)</h2><p></p>
<p>Problèmes de classification qui distingue plus de deux classes. Il existe par exemple environ 128 espèces d'érable. Un modèle les classant serait donc à classes multiples. À l'inverse, un modèle qui répartit les e-mails en seulement deux catégories, <em>spam</em> et <em>non-spam</em>, serait un <a href="#binary_classification"><strong>modèle de classification binaire</strong></a>.</p>
<p><a name="multinomial_classification"></a>
</p><h2 class="hide-from-toc"> classification multinomiale (multinomial classification)</h2><p></p>
<p>Synonyme de <a href="#multi-class"><strong>classification à classes multiples</strong></a>.</p>

<p><a name="NaN_trap"></a>
</p><h2 class="hide-from-toc"> piège NaN (NaN trap)</h2><p></p>
<p>Lorsqu'un nombre du modèle devient un <a href="https://en.wikipedia.org/wiki/NaN">NaN</a> pendant l'apprentissage et que, à la suite de ce changement, de nombreux autres nombres du modèle, voire tous, finissent par devenir également des NaN.</p>
<p>NaN est l'abréviation de "Not a Number" (Ce n'est pas un nombre).</p>
<p><a name="negative_class"></a>
</p><h2 class="hide-from-toc"> classe négative (negative class)</h2><p></p>
<p>Dans la <a href="#binary_classification"><strong>classification binaire</strong></a>, une classe est dite positive et l'autre négative. La classe positive est le résultat recherché et la classe négative l'autre possibilité.
Par exemple, la classe négative d'un test médical pourrait être "Pas de tumeur".
La classe négative d'un classificateur d'e-mail pourrait être "non-spam".
Voir aussi <a href="#positive_class"><strong>classe positive</strong></a>.</p>
<p><a name="neural_network"></a>
</p><h2 class="hide-from-toc"> réseau de neurones (neural network)</h2><p></p>
<p>Modèle inspiré du fonctionnement cérébral, et qui se compose de couches, dont au moins une est <a href="#hidden_layer"><strong>cachée</strong></a>, contenant des unités connectées simples, ou <a href="#neuron"><strong>neurones</strong></a>, suivies de non-linéarités.</p>
<p><a name="neuron"></a>
</p><h2 class="hide-from-toc"> neurone (neuron)</h2><p></p>
<p>Nœud d'un <a href="#neural_network"><strong>réseau de neurones</strong></a>, recevant plusieurs valeurs d'entrée et générant une valeur de sortie. Le neurone calcule la valeur de sortie en appliquant une <a href="#activation_function"><strong>fonction d'activation</strong></a> (transformation non linéaire) à une somme pondérée des valeurs d'entrée.</p>
<p><a name="node"></a>
</p><h2 class="hide-from-toc"> nœud (node)</h2><p></p>
<p>Ce terme complexe désigne l'un des deux concepts suivants, selon les cas :</p>
<ul>
<li>Un neurone dans une <a href="#hidden_layer"><strong>couche cachée</strong></a></li>
<li>Une opération dans un <a href="#graph"><strong>graphe</strong></a> TensorFlow</li>
</ul>
<p><a name="normalization"></a>
</p><h2 class="hide-from-toc"> normalisation (normalization)</h2><p></p>
<p>Conversion d'une plage réelle de valeurs en une plage standard de valeurs, généralement de -1 à +1 ou de 0 à 1. Supposons que la plage naturelle d'une certaine caractéristique s'étende de 800 à 6 000. En effectuant diverses soustractions et divisions, vous pouvez normaliser ces valeurs à une plage s'étendant de -1 à +1.</p>
<p>Voir aussi <a href="#scaling"><strong>mise à l'échelle</strong></a>.</p>
<p><a name="numerical_data"></a>
</p><h2 class="hide-from-toc"> données numériques (numerical data)</h2><p></p>
<p><a href="#feature"><strong>Caractéristiques</strong></a> représentées par des nombres entiers ou réels.
Par exemple, dans un modèle immobilier, vous pourriez probablement représenter la superficie d'un logement (en mètres carrés) sous forme de données numériques.  La représentation d'une caractéristique sous forme de données numériques indique que les valeurs de la caractéristique sont <em>mathématiquement</em> liées entre elles, et éventuellement avec l'étiquette.
Par exemple, le fait de représenter la superficie d'un logement sous forme de données numériques indique qu'une maison de 200 mètres carrés est deux fois plus spacieuse qu'une maison de 100 mètres carrés.
De plus, le nombre de mètres carrés d'une maison est probablement mathématiquement lié d'une manière ou d'une autre au prix de cette maison.</p>
<p>Les données entières ne doivent pas toutes être représentées sous forme de données numériques. Par exemple, les codes postaux dans certains pays sont des entiers, et ne doivent pas être représentés sous forme de données numériques dans les modèles. La raison à cela est que le code postal <code>20000</code> n'est pas deux fois plus (ou moins) puissant que le code postal 10000. Par ailleurs, bien que différents codes postaux <em>soient</em> corrélés à des prix de logement différents, il n'est pas possible de supposer que le prix des logements dont le code postal est 20000 est le double du prix des logements dont le code postal est 10000.
Les codes postaux doivent être représentés par des <a href="#categorical_data"><strong>données catégorielles</strong></a>.</p>
<p>Les caractéristiques numériques sont parfois appelées <a href="#continuous_feature"><strong>caractéristiques continues</strong></a>.</p>
<p><a name="numpy"></a>
</p><h2 class="hide-from-toc"> Numpy</h2><p></p>
<p><a href="http://www.numpy.org/">Bibliothèque mathématique Open Source</a> qui fournit différentes opérations de tableau efficaces pour Python. <a href="#pandas"><strong>Pandas</strong></a> est construit sur Numpy.</p>

<p><a name="objective"></a>
</p><h2 class="hide-from-toc"> objectif (objective)</h2><p></p>
<p>Statistique que votre algorithme essaie d'optimiser.</p>
<p><a name="offline_inference"></a>
</p><h2 class="hide-from-toc"> inférence hors ligne (offline inference)</h2><p></p>
<p>Création d'un groupe de <a href="#prediction"><strong>prédictions</strong></a>, stockage de ces prédictions, puis récupération de celles-ci à la demande. À comparer à l'<a href="#online_inference"><strong>inférence en ligne</strong></a>.</p>
<p><a name="one-hot_encoding"></a>
</p><h2 class="hide-from-toc"> encodage one-hot (one-hot encoding)</h2><p></p>
<p>Vecteur creux caractérisé ainsi :</p>
<ul>
<li>Un élément a la valeur 1.</li>
<li>Tous les autres éléments ont la valeur 0.</li>
</ul>
<p>L'encodage one-hot est couramment utilisé pour représenter des chaînes ou des identifiants qui ont un ensemble fini de valeurs possibles. Supposons qu'un ensemble de données botaniques donné répertorie 15 000 espèces différentes, chacune associée à un identifiant unique. Dans le cadre de l'extraction de caractéristiques, vous encoderez probablement ces identifiants sous forme de vecteurs one-hot, dont la taille est de 15 000.</p>
<p><a name="one-shot_learning"></a>
</p><h2 class="hide-from-toc"> apprentissage one-shot (one-shot learning)</h2><p></p>
<p>Approche du machine learning, souvent utilisée pour la classification d'objets, conçue pour apprendre des classificateurs efficaces à partir d'un seul exemple d'apprentissage.</p>
<p>Voir aussi <a href="#few-shot_learning"><strong>apprentissage few-shot</strong></a>.</p>
<p><a name="one-vs.-all"></a>
</p><h2 class="hide-from-toc"> un contre tous (one-vs.-all)</h2><p></p>
<p>Face à un problème de classification avec N solutions possibles, une solution un contre tous consiste en N <a href="#binary_classification"><strong>classificateurs binaires</strong></a> distincts : un classificateur binaire pour chaque résultat possible. Soit, par exemple, un modèle qui classe les exemples en animal, végétal ou minéral. Une solution un contre tous fournirait les trois classificateurs binaires distincts suivants :</p>
<ul>
<li>Animal contre non animal</li>
<li>Végétal contre non végétal</li>
<li>Minéral contre non minéral</li>
</ul>
<p><a name="online_inference"></a>
</p><h2 class="hide-from-toc"> inférence en ligne (online inference)</h2><p></p>
<p>Création de <a href="#prediction"><strong>prédictions</strong></a> à la demande. À comparer à l'<a href="#offline_inference"><strong>inférence hors ligne</strong></a>.</p>
<p><a name="Operation"></a>
</p><h2 class="hide-from-toc"> opération (Operation (op))</h2><p></p>
<p>Nœud du graphe TensorFlow. Dans TensorFlow, toute procédure qui crée, manipule ou détruit un <a href="#tensor"><strong>Tensor</strong></a> est une opération. Par exemple, une multiplication matricielle est une opération qui prend deux Tensors en entrée et crée un Tensor en sortie.</p>
<p><a name="optimizer"></a>
</p><h2 class="hide-from-toc"> optimiseur (optimizer)</h2><p></p>
<p>Implémentation particulière de l'algorithme de <a href="#gradient_descent"><strong>descente de gradient</strong></a>. La classe de base de TensorFlow pour les optimiseurs est <a href="https://www.tensorflow.org/api_docs/python/tf/train/Optimizer">tf.train.Optimizer</a>.
Différents optimiseurs peuvent utiliser un ou plusieurs des concepts suivants pour améliorer l'efficacité de la descente de gradient sur un <a href="#training_set"><strong>ensemble d'apprentissage</strong></a> donné :</p>
<ul>
<li>le <a href="https://www.tensorflow.org/api_docs/python/tf/train/MomentumOptimizer">moment</a>
    (Momentum) ;</li>
<li>la fréquence de mise à jour
    (<a href="https://www.tensorflow.org/api_docs/python/tf/train/AdagradOptimizer">AdaGrad</a>
    = descente de gradient adaptative ;
    <a href="https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer">Adam</a>
    = adaptative avec Momentum ; RMSProp) ;</li>
<li>la parcimonie/régularisation
    (<a href="https://www.tensorflow.org/api_docs/python/tf/train/FtrlOptimizer">Ftrl</a>) ;</li>
<li>des opérations mathématiques plus complexes
    (<a href="https://www.tensorflow.org/api_docs/python/tf/train/ProximalGradientDescentOptimizer">proximal</a>
    et autres).</li>
</ul>
<p>Il est même possible d'imaginer un <a href="https://arxiv.org/abs/1606.04474">optimiseur reposant sur un réseau de neurones</a>.</p>
<p><a name="outliers"></a>
</p><h2 class="hide-from-toc"> anomalies (outliers)</h2><p></p>
<p>Valeurs éloignées de la plupart des autres valeurs. Dans le machine learning, toutes les valeurs suivantes sont des anomalies :</p>
<ul>
<li><a href="#weight"><strong>Pondérations</strong></a> dont la valeur absolue est élevée</li>
<li>Valeurs prédites relativement éloignées des valeurs réelles</li>
<li>Données d'entrée dont les valeurs sont éloignées de plus de trois écarts types environ de la moyenne</li>
</ul>
<p>Les anomalies entraînent souvent des dysfonctionnements lors de l'entraînement du modèle.</p>
<p><a name="output_layer"></a>
</p><h2 class="hide-from-toc"> couche de sortie (output layer)</h2><p></p>
<p>Couche "finale" d'un réseau de neurones, et qui contient les réponses.</p>
<p><a name="overfitting"></a>
</p><h2 class="hide-from-toc"> surapprentissage (overfitting)</h2><p></p>
<p>Création d'un modèle correspondant si étroitement aux <a href="#training_set"><strong>données d'apprentissage</strong></a> qu'il ne parvient pas à effectuer des prédictions correctes avec de nouvelles données.</p>

<p><a name="pandas"></a>
</p><h2 class="hide-from-toc"> Pandas</h2><p></p>
<p>API d'analyse de données par colonne. De nombreux cadres de machine learning, y compris TensorFlow, acceptent les structures de données Pandas comme entrées. Voir la <a href="http://pandas.pydata.org/">documentation de Pandas</a>.</p>
<p><a name="parameter"></a>
</p><h2 class="hide-from-toc"> paramètre (parameter)</h2><p></p>
<p>Variable d'un modèle que le système de machine learning entraîne tout seul. Par exemple, les <a href="#weight"><strong>pondérations</strong></a> sont des paramètres dont le système de machine learning apprend progressivement les valeurs via des itérations d'apprentissage successives. À comparer aux <a href="#hyperparameter"><strong>hyperparamètres</strong></a>.</p>
<p><a name="Parameter_Server"></a>
</p><h2 class="hide-from-toc"> serveur de paramètres (Parameter Server (PS))</h2><p></p>
<p>Tâche qui effectue le suivi des <a href="#parameter"><strong>paramètres</strong></a> d'un modèle dans une configuration distribuée.</p>
<p><a name="parameter_update"></a>
</p><h2 class="hide-from-toc"> mise à jour des paramètres (parameter update)</h2><p></p>
<p>Opération qui consiste à ajuster les <a href="#parameter"><strong>paramètres</strong></a> d'un modèle au cours de l'apprentissage, généralement au cours d'une seule itération de la <a href="#gradient_descent"><strong>descente de gradient</strong></a>.</p>
<p><a name="partial_derivative"></a>
</p><h2 class="hide-from-toc"> dérivée partielle (partial derivative)</h2><p></p>
<p>Dérivée dans laquelle toutes les variables sauf une sont considérées comme constantes.
Par exemple, la dérivée partielle de <em>f(x, y)</em> par rapport à <em>x</em> est la dérivée de <em>f</em> considérée exclusivement comme une fonction de <em>x</em> (c'est-à-dire en gardant <em>y</em> constante). La dérivée partielle de <em>f</em> par rapport à <em>x</em> se concentre uniquement sur l'évolution de <em>x</em> et ignore toutes les autres variables de l'équation.</p>
<p><a name="partitioning_strategy"></a>
</p><h2 class="hide-from-toc"> stratégie de partitionnement (partitioning strategy)</h2><p></p>
<p>Algorithme qui répartit les variables entre les <a href="#Parameter_Server"><strong>serveurs de paramètres</strong></a>.</p>
</p><p><a name="performance"></a>
</p><h2 class="hide-from-toc"> performances (performance)</h2><p></p>
<p>Terme complexe ayant plusieurs significations :</p>
<ul>
<li>Sens traditionnel dans le génie logiciel, à savoir : à quelle vitesse, ou avec quelle efficacité, ce logiciel s'exécute-t-il ?</li>
<li>Sens dans le domaine du machine learning, à savoir : quel est le degré d'exactitude de ce <a href="#model"><strong>modèle</strong></a> ? Autrement dit, les prédictions du modèle sont-elles bonnes ?</li>
</ul>
<p><a name="perplexity"></a>
</p><h2 class="hide-from-toc"> perplexité (perplexity)</h2><p></p>
<p>Mesure de l'efficacité d'un <a href="#model"><strong>modèle</strong></a> à exécuter une tâche.
Supposons que vous deviez lire les premières lettres qu'un utilisateur saisit avec le clavier de son smartphone pour lui proposer une liste de mots possibles. Pour cette tâche, la perplexité, notée P, est environ égale au nombre de mots que vous devez proposer pour que votre liste contienne le mot que l'utilisateur souhaite effectivement saisir.</p>
<p>La perplexité est liée à l'<a href="#cross-entropy"><strong>entropie croisée</strong></a> par la formule suivante :</p>
<div>
$$P= 2^{-\text{entropie croisée}}$$
</div>

<p><a name="pipeline"></a>
</p><h2 class="hide-from-toc"> pipeline</h2><p></p>
<p>Infrastructure sur laquelle repose l'algorithme de machine learning. Le pipeline inclut la collecte des données, l'intégration de celles-ci dans des fichiers de données d'apprentissage, l'entraînement d'un ou plusieurs modèles, et l'exportation des modèles en production.</p>
<p><a name="pooling"></a>
</p><h2 class="hide-from-toc"> pooling</h2><p></p>
<p>Réduction d'une matrice (ou de matrices) créée par une <a href="#convolutional_layer"><strong>couche convolutive</strong></a> antérieure à une matrice plus petite.
Le pooling implique généralement de prendre la valeur maximale ou la valeur moyenne de l'ensemble de la zone regroupée. Soit, par exemple, la matrice 3 x 3 suivante :</p>
<p>
<img src="/machine-learning/glossary/images/PoolingStart.svg">
</p>

<p>Une opération de pooling, tout comme une opération convolutive, divise cette matrice en tranches, puis déplace cette opération convolutive selon un certain <a href="#stride"><strong>pas</strong></a>. Supposons que l'opération de pooling divise la matrice convolutive en tranches de taille 2 x 2 avec un pas de 1 x 1.
Comme l'illustre le diagramme suivant, quatre opérations de pooling ont lieu.
Imaginons que chaque opération de pooling sélectionne la valeur maximale des quatre valeurs de cette tranche :</p>
<p>
<img src="/machine-learning/glossary/images/PoolingConvolution.svg">
</p>

<p>Le pooling permet d'appliquer l'<a href="#translational_invariance"><strong>invariance de translation</strong></a> dans la matrice d'entrée.</p>
<p>Dans les applications de vision, le pooling est officiellement appelé <strong>pooling spatial</strong>.
Dans les applications de séries temporelles, le pooling est généralement appelé <strong>pooling temporel</strong>.
Plus couramment, le pooling est fréquemment désigné par les termes de <strong>sous-échantillonnage</strong> ou <strong>réduction d'échantillonnage</strong>.</p>
<p><a name="positive_class"></a>
</p><h2 class="hide-from-toc"> classe positive (positive class)</h2><p></p>
<p>Dans la <a href="#binary_classification"><strong>classification binaire</strong></a>, les deux classes possibles sont étiquetées "positive" et "négative". Le résultat positif correspond à ce qui est testé. (Certes, les deux résultats sont testés simultanément, mais mettons cette considération de côté.) Par exemple, la classe positive d'un test médical pourrait être "tumeur". La classe positive d'un classificateur d'e-mail pourrait être "spam".</p>
<p>À comparer à la <a href="#negative_class"><strong>classe négative</strong></a>.</p>
<p><a name="precision"></a>
</p><h2 class="hide-from-toc"> précision (precision)</h2><p></p>
<p>Statistique des <a href="#classification_model"><strong>modèles de classification</strong></a>. La précision correspond à la fréquence à laquelle le modèle prédit correctement la <a href="#positive_class"><strong>classe positive</strong></a>. Par exemple :</p>
<div>
$$\text{Précision} =
\frac{\text{Vrais positifs}} {\text{Vrais positifs} + \text{Faux positifs}}$$
</div>

<p><a name="prediction"></a>
</p><h2 class="hide-from-toc"> prédiction (prediction)</h2><p></p>
<p>Résultat d'un modèle auquel un <a href="#example"><strong>exemple</strong></a> est fourni en entrée.</p>
<p><a name="prediction_bias"></a>
</p><h2 class="hide-from-toc"> biais de prédiction (prediction bias)</h2><p></p>
<p>Valeur indiquant la distance entre la moyenne des <a href="#prediction"><strong>prédictions</strong></a> et la moyenne des <a href="#label"><strong>étiquettes</strong></a> dans un ensemble de données.</p>
<p><a name="pre-made_Estimator"></a>
</p><h2 class="hide-from-toc"> Estimator prédéfini (pre-made Estimator)</h2><p></p>
<p><a href="#Estimator"><strong>Estimator</strong></a> déjà créé.
TensorFlow propose plusieurs Estimators prédéfinis, notamment <code>DNNClassifier</code>, <code>DNNRegressor</code> et <code>LinearClassifier</code>.  Pour créer vos propres Estimators prédéfinis, <a href="https://www.tensorflow.org/extend/estimators">suivez cette procédure</a>.</p>
<p><a name="pre-trained_model"></a>
</p><h2 class="hide-from-toc"> modèle pré-entraîné (pre-trained model)</h2><p></p>
<p>Modèles ou composants de modèle (par exemple, <a href="#embeddings"><strong>représentations vectorielles continues</strong></a>) qui ont déjà été entraînés. Dans certains cas, vous alimentez un <a href="#neural_network"><strong>réseau de neurones</strong></a> avec des représentations vectorielles continues pré-entraînées. Dans d'autres cas, votre modèle entraîne lui-même les représentations vectorielles continues plutôt que d'utiliser des représentations vectorielles pré-entraînées.</p>
<p><a name="prior_belief"></a>
</p><h2 class="hide-from-toc"> croyance antérieure (prior belief)</h2><p></p>
<p>Ce que vous croyez à propos des données avant de commencer l'apprentissage avec celles-ci. Par exemple, la <a href="#L2_regularization"><strong>régularisation L<sub>2</sub></strong></a> repose sur une croyance antérieure que les <a href="#weight"><strong>pondérations</strong></a> devraient être faibles et normalement distribuées autour de zéro.</p>

<p><a name="queue"></a>
</p><h2 class="hide-from-toc"> file d'attente (queue)</h2><p></p>
<p><a href="#Operation"><strong>Opération</strong></a> TensorFlow qui implémente une structure de données de file d'attente. Généralement utilisée dans les E/S.</p>

<p><a name="rank"></a>
</p><h2 class="hide-from-toc"> rang (rank)</h2><p></p>
<p>Terme aux significations multiples dans le machine learning :</p>
<ul>
<li>Nombre de dimensions d'un <a href="#tensor"><strong>Tensor</strong></a>. Par exemple, une grandeur scalaire a un rang de 0, un vecteur un rang de 1 et une matrice un rang de 2.</li>
<li>Position ordinale d'une classe dans un problème de machine learning qui hiérarchise des classes par ordre décroissant. Par exemple, un système de classement de comportement pourrait classer les récompenses pour un chien de la récompense la plus élevée (un steak) à la récompense la plus faible (du chou frisé flétri).</li>
</ul>
<p><a name="rater"></a>
</p><h2 class="hide-from-toc"> évaluateur (rater)</h2><p></p>
<p>Personne qui fournit les <a href="#label"><strong>étiquettes</strong></a> dans les <a href="#example"><strong>exemples</strong></a>.
Parfois appelé "annotateur".</p>
<p><a name="recall"></a>
</p><h2 class="hide-from-toc"> rappel (recall)</h2><p></p>
<p>Statistique des <a href="#classification_model"><strong>modèles de classification</strong></a> qui répond à la question suivante : parmi toutes les étiquettes positives possibles, combien d'entre elles le modèle a-t-il correctement identifiées ? En d'autres termes :</p>
<p>$$\text{Rappel} =
\frac{\text{Vrais positifs}} {\text{Vrais positifs} + \text{Faux négatifs}}
$$</p>
<p><a name="ReLU"></a>
</p><h2 class="hide-from-toc"> unité de rectification linéaire (ReLU) (Rectified Linear Unit (ReLU))</h2><p></p>
<p><a href="#activation_function"><strong>Fonction d'activation</strong></a> dont les règles sont les suivantes :</p>
<ul>
<li>Si l'entrée est négative ou égale à zéro, la sortie est zéro.</li>
<li>Si l'entrée est positive, la sortie est égale à l'entrée.</li>
</ul>
<p><a name="regression_model"></a>
</p><h2 class="hide-from-toc"> modèle de régression (regression model)</h2><p></p>
<p>Type de modèle qui génère des valeurs continues (à virgule flottante, généralement).
À comparer aux <a href="#classification_model"><strong>modèles de classification</strong></a>, qui génèrent des valeurs discrètes, comme "hémérocalle" ou "lis tigré".</p>
<p><a name="regularization"></a>
</p><h2 class="hide-from-toc"> régularisation (regularization)</h2><p></p>
<p>Pénalité pour la complexité d'un modèle. La régularisation aide à éviter le <a href="#overfitting"><strong>surapprentissage</strong></a>. Les différents types de régularisation sont notamment :</p>
<ul>
<li><a href="#L1_regularization"><strong>Régularisation L<sub>1</sub></strong></a></li>
<li><a href="#L2_regularization"><strong>Régularisation L<sub>2</sub></strong></a></li>
<li><a href="#dropout_regularization"><strong>Régularisation par abandon</strong></a></li>
<li><a href="#early_stopping"><strong>Arrêt prématuré</strong></a> (Il ne s'agit pas vraiment d'une méthode de régularisation, mais l'arrêt prématuré peut limiter efficacement le surapprentissage.)</li>
</ul>
<p><a name="regularization_rate"></a>
</p><h2 class="hide-from-toc"> taux de régularisation (regularization rate)</h2><p></p>
<p>Grandeur scalaire, notée lambda, qui indique l'importance relative de la fonction de régularisation. L'équation de <a href="#loss"><strong>perte</strong></a> simplifiée suivante montre l'influence du taux de régularisation :</p>
<div>
$$\text{minimiser(fonction de perte + }\lambda\text{(fonction de régularisation))}$$
</div>

<p>L'augmentation du taux de régularisation réduit non seulement le <a href="#overfitting"><strong>surapprentissage</strong></a>, mais aussi la <a href="#accuracy"><strong>justesse</strong></a> du modèle.</p>
<p><a name="representation"></a>
</p><h2 class="hide-from-toc"> représentation (representation)</h2><p></p>
<p>Processus de mise en correspondance des données et des <a href="#feature"><strong>caractéristiques</strong></a> utiles.</p>
<p><a name="ROC"></a>
</p><h2 class="hide-from-toc"> courbe ROC (receiver operating characteristic) (ROC (receiver operating characteristic) Curve)</h2><p></p>
<p>Courbe représentant le <a href="#TP_rate"><strong>taux de vrais positifs</strong></a> et le <a href="#FP_rate"><strong>taux de faux positifs</strong></a> pour différents <a href="#classification_threshold"><strong>seuils de classification</strong></a>. Voir aussi <a href="#AUC"><strong>AUC</strong></a>.</p>
<p><a name="root_directory"></a>
</p><h2 class="hide-from-toc"> répertoire racine (root directory)</h2><p></p>
<p>Répertoire que vous spécifiez pour l'enregistrement des sous-répertoires du point de contrôle TensorFlow et des fichiers d'événements de plusieurs modèles.</p>
<p><a name="RMSE"></a>
</p><h2 class="hide-from-toc"> racine carrée de l'erreur quadratique moyenne (RMSE) (Root Mean Squared Error (RMSE))</h2><p></p>
<p>Racine carrée de l'<a href="#MSE"><strong>erreur quadratique moyenne</strong></a>.</p>
<p><a name="rotational_invariance"></a>
</p><h2 class="hide-from-toc"> invariance rotationnelle (rotational invariance)</h2><p></p>
<p>Dans un problème de classification d'images, capacité d'un algorithme à classer correctement des images même lorsque l'orientation de l'image change. Par exemple, l'algorithme peut identifier une raquette de tennis comme telle, qu'elle soit pointée vers le haut, vers le bas, vers la gauche ou vers la droite. Notez que l'invariance rotationnelle n'est pas toujours souhaitable. Par exemple, un 9 à l'envers ne devrait pas être classé comme étant un 9.</p>
<p>Voir aussi <a href="#translational_invariance"><strong>invariance de translation</strong></a> et <a href="#size_invariance"><strong>invariance de taille</strong></a>.</p>

<p><a name="SavedModel"></a>
</p><h2 class="hide-from-toc"> SavedModel</h2><p></p>
<p>Format recommandé pour l'enregistrement et la récupération des modèles TensorFlow. SavedModel est un format de sérialisation récupérable, de langage neutre, qui permet aux systèmes et aux outils de plus haut niveau de produire, consommer et transformer des modèles TensorFlow.</p>
<p>Pour plus d'informations, consultez l'article <a href="https://www.tensorflow.org/programmers_guide/saved_model">Enregistrer et récupérer</a> du guide du programmeur TensorFlow.</p>
<p><a name="Saver"></a>
</p><h2 class="hide-from-toc"> Saver</h2><p></p>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/train/Saver">Objet TensorFlow</a> responsable de l'enregistrement des points de contrôle du modèle.</p>
<p><a name="scaling"></a>
</p><h2 class="hide-from-toc"> mise à l'échelle (scaling)</h2><p></p>
<p>Pratique couramment utilisée dans l'<a href="#feature_engineering"><strong>extraction de caractéristiques</strong></a> pour faire correspondre la plage de valeurs d'une caractéristique à celle d'autres caractéristiques de l'ensemble de données. Supposons que vous souhaitiez que la plage de toutes les caractéristiques à virgule flottante de l'ensemble de données s'étende de 0 à 1. Si la plage d'une caractéristique particulière s'étend de 0 à 500, vous pouvez mettre à l'échelle cette valeur en divisant chaque valeur par 500.</p>
<p>Voir aussi <a href="#normalization"><strong>normalisation</strong></a>.</p>
<p><a name="scikit-learn"></a>
</p><h2 class="hide-from-toc"> scikit-learn</h2><p></p>
<p>Plate-forme de machine learning Open Source populaire. Pour plus d'informations, rendez-vous sur le site <a href="http://www.scikit-learn.org/">www.scikit-learn.org</a>.</p>
<p><a name="semi-supervised_learning"></a>
</p><h2 class="hide-from-toc"> apprentissage partiellement supervisé (semi-supervised learning)</h2><p></p>
<p>Entraînement d'un modèle avec des données où seulement certains des exemples d'apprentissage sont étiquetés. L'une des techniques d'apprentissage partiellement supervisé consiste à déduire les étiquettes des exemples sans étiquette, puis à entraîner le modèle avec les étiquettes déduites afin de créer un nouveau modèle. L'apprentissage partiellement supervisé peut être utile si les étiquettes sont coûteuses, mais que les exemples sans étiquette abondent.</p>
<p><a name="sequence_model"></a>
</p><h2 class="hide-from-toc"> modèle de séquence (sequence model)</h2><p></p>
<p>Modèle dont les entrées présentent une dépendance séquentielle. Par exemple, prévision de la prochaine vidéo visionnée à partir d'une séquence de vidéos précédemment regardées.</p>
</p><p><a name="session"></a>
</p><h2 class="hide-from-toc"> session (tf.session)</h2><p></p>
<p>Objet qui encapsule l'état de l'exécution de TensorFlow, et exécute tout ou partie d'un <a href="#graph"><strong>graphe</strong></a>. Lorsque vous utilisez les API TensorFlow de bas niveau, vous instanciez et gérez directement un ou plusieurs objets <code>tf.session</code>. Lorsque vous utilisez l'API Estimators, les Estimators instancient des objets session pour vous.</p>
</p><p><a name="sigmoid_function"></a>
</p><h2 class="hide-from-toc"> fonction sigmoïde (sigmoid function)</h2><p></p>
<p>Fonction qui met en correspondance le résultat d'une régression logistique ou multinomiale (logarithme de probabilité) avec des probabilités, et renvoie une valeur comprise entre 0 et 1.  L'équation de la fonction sigmoïde est la suivante :</p>
<div>
$$y = \frac{1}{1 + e^{-\sigma}}$$
</div>

<p>où \(\sigma\), dans les problèmes de <a href="#logistic_regression"><strong>régression logistique</strong></a>, est simplement :</p>
<div>
$$\sigma = b + w_1x_1 + w_2x_2 + … w_nx_n$$
</div>

<p>En d'autres termes, la fonction sigmoïde convertit \(\sigma\) en une probabilité comprise entre 0 et 1.</p>
<p>Dans certains <a href="#neural_network"><strong>réseaux de neurones</strong></a>, la fonction sigmoïde est utilisée comme <a href="#activation_function"><strong>fonction d'activation</strong></a>.</p>
<p><a name="size_invariance"></a>
</p><h2 class="hide-from-toc"> invariance de taille (size invariance)</h2><p></p>
<p>Dans un problème de classification d'images, capacité d'un algorithme à classer correctement des images même lorsque la taille de l'image change. Par exemple, l'algorithme peut identifier un chat comme tel, que la taille de l'image soit de 2 millions de pixels ou de 200 000 pixels. Notez que même les meilleurs algorithmes de classification d'images présentent encore des limites pratiques au niveau de l'invariance de taille.
Par exemple, il est peu probable qu'un algorithme (ou une personne) puisse classer correctement une image de chat de seulement 20 pixels.</p>
<p>Voir aussi <a href="#translational_invariance"><strong>invariance de translation</strong></a> et <a href="#rotational_invariance"><strong>invariance rotationnelle</strong></a>.</p>
<p><a name="softmax"></a>
</p><h2 class="hide-from-toc"> softmax</h2><p></p>
<p>Fonction qui fournit les probabilités pour chaque classe possible dans un <a href="#multi-class"><strong>modèle de classification à classes multiples</strong></a>. La somme des probabilités est de 1. Par exemple, softmax peut déterminer que la probabilité qu'une image particulière soit celle d'un chien est de 0,9, d'un chat de 0,08 et d'un cheval de 0,02.
Également appelé <strong>softmax complet</strong>.</p>
<p>À comparer à l'<a href="#candidate_sampling"><strong>échantillonnage de candidats</strong></a>.</p>
<p><a name="sparse_features"></a>
</p><h2 class="hide-from-toc"> caractéristique creuse (sparse feature)</h2><p></p>
<p>Vecteur de <a href="#feature"><strong>caractéristique</strong></a> dont les valeurs sont pour la plupart nulles ou vides.
Par exemple, un vecteur contenant une seule valeur 1 et un million de valeurs 0 est dit creux. Autre exemple : les mots d'une requête de recherche peuvent aussi être une caractéristique creuse. En effet, il existe de très nombreux mots possibles dans une langue donnée, mais seuls quelques-uns d'entre eux peuvent apparaître dans une requête.</p>
<p>À comparer à la <a href="#dense_feature"><strong>caractéristique dense</strong></a>.</p>
<p><a name="sparse_representation"></a>
</p><h2 class="hide-from-toc"> représentation creuse (sparse representation)</h2><p></p>
<p><a href="#representation"><strong>Représentation</strong></a> d'un Tensor qui ne stocke que des éléments différents de zéro.</p>
<p>Par exemple, la langue anglaise comprend environ un million de mots.
Considérons deux façons de représenter un nombre de mots utilisés dans une phrase en anglais :</p>
<ul>
<li>Une <strong>représentation dense</strong> de cette phrase doit définir un entier pour un million de cellules, en plaçant un 0 dans la plupart d'entre eux et un entier faible dans quelques-unes d'entre elles.</li>
<li>Une représentation creuse de cette phrase ne stocke que les cellules qui symbolisent un mot effectivement utilisé dans la phrase. Ainsi, si la phrase ne contenait que 20 mots uniques, la représentation creuse de la phrase stockerait un entier dans 20 cellules seulement.</li>
</ul>
<p>À titre d'exemple, voyons deux façons de représenter la phrase "Dogs Wag Tails."
Comme le montrent les tableaux suivants, la représentation dense consomme environ un million de cellules, tandis que la représentation creuse n'en consomme que 3 :</p>
<div id="sparse-dense-tables">
<table id="sparse-table">
<caption>Représentation dense</caption>
<thead>
  <tr>
  <th>Numéro de la cellule</th>
  <th>Mot</th>
  <th>Occurrence</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>0</td>
    <td>a</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>aardvark</td>
    <td>0</td>
  </tr>
  <tr>
    <td>2</td>
    <td>aargh</td>
    <td>0</td>
  </tr>
  <tr>
    <td>3</td>
    <td>aarti</td>
    <td>0</td>
  </tr>
  <tr class="elided-rows">
    <td colspan="3"><strong>… 140 391 mots supplémentaires avec une occurrence de 0</strong></td>
  </tr>
  <tr>
    <td>140395</td>
    <td>dogs</td>
    <td>1</td>
  </tr>
  <tr class="elided-rows">
    <td colspan="3"><strong>… 633 062 mots avec une occurrence de 0</strong></td>
  </tr>
  <tr>
    <td>773458</td>
    <td>tails</td>
    <td>1</td>
  </tr>
  <tr class="elided-rows">
    <td colspan="3"><strong>… 189 136 mots avec une occurrence de 0</strong></td>
  </tr>
  <tr>
    <td>962594</td>
    <td>wag</td>
    <td>1</td>
  </tr>
  <tr class="elided-rows">
    <td colspan="3"><strong>… de nombreux autres mots avec une occurrence de 0</strong></td>
  </tr>
</tbody>
</table>

<table id="dense-table">
<caption>Représentation creuse</caption>
<thead>
  <tr>
  <th>Numéro de la cellule</th>
  <th>Mot</th>
  <th>Occurrence</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>140395</td>
  <td>dogs</td>
  <td>1</td>
</tr>
<tr>
  <td>773458</td>
  <td>tails</td>
  <td>1</td>
</tr>
<tr>
  <td>962594</td>
  <td>wag</td>
  <td>1</td>
</tr>
</tbody>
</table>
</div>

<p><a name="sparsity"></a>
</p><h2 class="hide-from-toc"> parcimonie (sparsity)</h2><p></p>
<p>Nombre d'éléments égaux à zéro (ou null) dans un vecteur ou une matrice divisé par le nombre total d'entrées dans ce vecteur ou cette matrice. Considérons par exemple une matrice 10 x 10 dans laquelle 98 cellules contiennent zéro. La formule permettant de calculer la parcimonie est la suivante :</p>
<div>
$$
{\text{parcimonie}} =
\frac{\text{98}} {\text{100}} =
{\text{0.98}}
$$
</div>

<p>La <strong>parcimonie des caractéristiques</strong> désigne la parcimonie d'un vecteur de caractéristiques. La <strong>parcimonie du modèle</strong> désigne la parcimonie des pondérations du modèle.</p>
<p><a name="spatial_pooling"></a>
</p><h2 class="hide-from-toc"> pooling spatial (spatial pooling)</h2><p></p>
<p>Voir <a href="#pooling"><strong>pooling</strong></a>.</p>
<p><a name="squared_hinge_loss"></a>
</p><h2 class="hide-from-toc"> marge maximale quadratique (squared hinge loss)</h2><p></p>
<p>Carré de la <a href="#hinge-loss"><strong>marge maximale</strong></a>.  La marge maximale quadratique pénalise les anomalies plus sévèrement que la marge maximale classique.</p>
<p><a name="squared_loss"></a>
</p><h2 class="hide-from-toc"> perte quadratique (squared loss)</h2><p></p>
<p>Fonction de <a href="#loss"><strong>perte</strong></a> utilisée dans la <a href="#linear_regression"><strong>régression linéaire</strong></a>,  également appelée <strong>perte L<sub>2</sub></strong>. Cette fonction calcule les carrés de la différence entre la valeur prédite d'un modèle pour un <a href="#example"><strong>exemple</strong></a> étiqueté et la valeur réelle de l'<a href="#label"><strong>étiquette</strong></a>.
En raison de la mise au carré, cette fonction de perte amplifie l'influence des mauvaises prédictions.
En d'autres termes, la perte quadratique réagit plus fortement aux anomalies que la <a href="#L1_loss"><strong>perte L<sub>1</sub></strong></a>.</p>
<p><a name="static_model"></a>
</p><h2 class="hide-from-toc"> modèle statique (static model)</h2><p></p>
<p>Modèle entraîné hors ligne.</p>
<p><a name="stationarity"></a>
</p><h2 class="hide-from-toc"> stationnarité (stationarity)</h2><p></p>
<p>Propriété des données d'un ensemble, caractérisée par le fait que la distribution des données reste constante entre une ou plusieurs dimensions. Le plus souvent, cette dimension est le temps. Cela signifie alors que les données stationnaires n'évoluent pas au fil du temps. Par exemple, les données stationnaires n'évoluent pas entre septembre et décembre.</p>
<p><a name="step"></a>
</p><h2 class="hide-from-toc"> pas (step)</h2><p></p>
<p>Évaluation avant et arrière d'un <a href="#batch"><strong>lot</strong></a>.</p>
<p><a name="step_size"></a>
</p><h2 class="hide-from-toc"> pas d'apprentissage (step size)</h2><p></p>
<p>Synonyme de <a href="#learning_rate"><strong>taux d'apprentissage</strong></a>.</p>
<p><a name="SGD"></a>
</p><h2 class="hide-from-toc"> descente de gradient stochastique (SGD) (stochastic gradient descent (SGD))</h2><p></p>
<p>Algorithme de <a href="#gradient_descent"><strong>descente de gradient</strong></a> dans lequel la taille de lot est égale à un. Autrement dit, la descente de gradient stochastique repose sur un seul exemple prélevé uniformément, de manière aléatoire, dans un ensemble de données afin de calculer une estimation du gradient à chaque pas.</p>
<p><a name="stride"></a>
</p><h2 class="hide-from-toc"> pas (stride)</h2><p></p>
<p>Dans une opération de convolution ou de pooling, delta dans chaque dimension entre deux tranches d'entrée consécutives. Par exemple, l'animation suivante montre un pas de (1,1) lors d'une opération de convolution. La tranche d'entrée suivante commence ainsi une position à droite de la tranche d'entrée précédente. Lorsque l'opération atteint le bord droit, la tranche suivante se trouve complètement à gauche, mais une position vers le bas.</p>
<p>
<img src="/machine-learning/glossary/images/AnimatedConvolution.gif"/>
</p>

<p>L'exemple précédent illustre le cas d'un pas bidimensionnel.  Si la matrice d'entrée est tridimensionnelle, le pas est également tridimensionnel.</p>
<p><a name="SRM"></a>
</p><h2 class="hide-from-toc"> minimisation du risque structurel (SRM) (structural risk minimization (SRM))</h2><p></p>
<p>Algorithme qui concilie les deux objectifs suivants :</p>
<ul>
<li>Créer le modèle prédictif le plus efficace (par exemple, perte la plus faible)</li>
<li>Créer un modèle aussi simple que possible (par exemple, forte régularisation)</li>
</ul>
<p>Par exemple, une fonction qui minimise la perte et effectue la régularisation sur l'ensemble d'apprentissage est un algorithme de minimisation du risque structurel.</p>
<p>Pour plus d'informations, consultez la page <a href="http://www.svms.org/srm/">http://www.svms.org/srm/</a>.</p>
<p>À comparer avec la <a href="#ERM"><strong>minimisation du risque empirique</strong></a>.</p>
<p><a name="subsampling"></a>
</p><h2 class="hide-from-toc"> sous-échantillonnage (subsampling)</h2><p></p>
<p>Voir <a href="#pooling"><strong>pooling</strong></a>.</p>
<p><a name="summary"></a>
</p><h2 class="hide-from-toc"> résumé (summary)</h2><p></p>
<p>Dans TensorFlow, valeur ou ensemble de valeurs calculées à un <a href="#step"><strong>pas</strong></a> donné, généralement utilisé pour effectuer le suivi des statistiques du modèle pendant l'apprentissage.</p>
<p><a name="supervised_machine_learning"></a>
</p><h2 class="hide-from-toc"> machine learning supervisé (supervised machine learning)</h2><p></p>
<p>Entraînement d'un <a href="#model"><strong>modèle</strong></a> à partir de données d'entrée et des <a href="#label"><strong>étiquettes</strong></a> correspondantes. Le machine learning supervisé est comparable à l'apprentissage par un élève d'un sujet en étudiant une série de questions et les réponses correspondantes.  Une fois la correspondance entre les questions et les réponses maîtrisée, l'élève peut fournir les réponses à des questions nouvelles (jamais vues auparavant) sur le même sujet.  À comparer au <a href="#unsupervised_machine_learning"><strong>machine learning non supervisé</strong></a>.</p>
<p><a name="synthetic_feature"></a>
</p><h2 class="hide-from-toc"> caractéristique synthétique (synthetic feature)</h2><p></p>
<p><a href="#feature"><strong>Caractéristique</strong></a> absente des caractéristiques d'entrée, mais créée à partir d'une ou plusieurs d'entre elles. Exemples de types de caractéristiques synthétiques :</p>
<ul>
<li><a href="#bucketing"><strong>Binning</strong></a> d'une caractéristique continue dans des paquets de plage</li>
<li>Multiplication (ou division) d'une caractéristique par d'autres caractéristiques ou par elle-même </li>
<li>Création d'une <a href="#feature_cross"><strong>croisement de caractéristiques</strong></a></li>
</ul>
<p>Les caractéristiques créées uniquement par <a href="#normalization"><strong>normalisation</strong></a> ou <a href="#scaling"><strong>mise à l'échelle</strong></a> ne sont pas considérées comme des caractéristiques synthétiques.</p>

<p><a name="target"></a>
</p><h2 class="hide-from-toc"> cible (target)</h2><p></p>
<p>Synonyme d'<a href="#label"><strong>étiquette</strong></a>.</p>
<p><a name="temporal_data"></a>
</p><h2 class="hide-from-toc"> données temporelles (temporal data)</h2><p></p>
<p>Données enregistrées à différents moments. Par exemple, les ventes de manteaux d'hiver enregistrées pour chaque jour de l'année sont des données temporelles.</p>
<p><a name="tensor"></a>
</p><h2 class="hide-from-toc"> Tensor</h2><p></p>
<p>Structure de données principale des programmes TensorFlow. Les Tensors sont des structures de données à N dimensions (la valeur de N pouvant être très grande), généralement des grandeurs scalaires, des vecteurs ou des matrices. Les éléments d'un Tensor peuvent contenir des valeurs de type entier, à virgule flottante ou chaîne.</p>
<p><a name="TPU"></a>
</p><h2 class="hide-from-toc"> Tensor Processing Unit (TPU)</h2><p></p>
<p>ASIC (circuit intégré propre à une application) qui optimise les performances des programmes TensorFlow.</p>
<p><a name="tensor_rank"></a>
</p><h2 class="hide-from-toc"> rang de Tensor (Tensor rank)</h2><p></p>
<p>Voir <a href="#rank"><strong>rang</strong></a>.</p>
<p><a name="tensor_shape"></a>
</p><h2 class="hide-from-toc"> forme du Tensor (Tensor shape)</h2><p></p>
<p>Nombre d'éléments d'un <a href="#tensor"><strong>Tensor</strong></a> dans différentes dimensions.
Par exemple, un Tensor [5, 10] a une forme de 5 dans une dimension et de 10 dans une autre.</p>
<p><a name="tensor_size"></a>
</p><h2 class="hide-from-toc"> taille de Tensor (Tensor size)</h2><p></p>
<p>Nombre total de grandeurs scalaires d'un <a href="#tensor"><strong>Tensor</strong></a>. Par exemple, la taille d'un Tensor [5, 10] est de 50.</p>
<p><a name="TensorBoard"></a>
</p><h2 class="hide-from-toc"> TensorBoard</h2><p></p>
<p>Tableau de bord qui affiche les résumés enregistrés lors de l'exécution d'un ou de plusieurs programmes TensorFlow.</p>
<p><a name="TensorFlow"></a>
</p><h2 class="hide-from-toc"> TensorFlow</h2><p></p>
<p>Plate-forme étendue distribuée de machine learning. Le terme désigne également la couche API de base de la pile TensorFlow qui soutient les calculs généraux des graphes Dataflow.</p>
<p>Bien que TensorFlow soit principalement utilisé pour le machine learning, il peut aussi être utilisé pour des tâches autres nécessitant un calcul numérique à l'aide de graphes Dataflow.</p>
<p><a name="TensorFlow_Playground"></a>
</p><h2 class="hide-from-toc"> TensorFlow Playground</h2><p></p>
<p>Programme qui visualise l'influence de différents <a href="#hyperparameters"><strong>hyperparamètres</strong></a> sur l'entraînement d'un modèle (principalement un réseau de neurones).
Pour découvrir TensorFlow Playground, rendez-vous sur le site <a href="http://playground.tensorflow.org">http://playground.tensorflow.org</a>.</p>
<p><a name="TensorFlow_Serving"></a>
</p><h2 class="hide-from-toc"> TensorFlow Serving</h2><p></p>
<p>Plate-forme permettant de déployer des modèles entraînés en production.</p>
<p><a name="test_set"></a>
</p><h2 class="hide-from-toc"> ensemble d'évaluation (test set)</h2><p></p>
<p>Sous-ensemble de l'ensemble de données utilisé pour tester votre <a href="#model"><strong>modèle</strong></a> après approbation initiale de celui-ci par l'ensemble de validation.
</p><p>À comparer avec l'<a href="#training_set"><strong>ensemble d'apprentissage</strong></a> et l'<a href="#validation_set"><strong>ensemble de validation</strong></a>.</p>
<p><a name="tf.Example"></a>
</p><h2 class="hide-from-toc"> tf.Example</h2><p></p>
<p><a href="https://developers.google.com/protocol-buffers/">Protocol Buffer</a> standard pour la description des données d'entrée, pour l'inférence ou l'entraînement d'un modèle de machine learning.</p>
<p><a name="time_series_analysis"></a>
</p><h2 class="hide-from-toc"> analyse de séries temporelles (time series analysis)</h2><p></p>
<p>Sous-domaine du machine learning et de la statistique qui analyse les <a href="#temporal_data"><strong>données temporelles</strong></a>.  De nombreux types de problèmes de machine learning nécessitent une analyse de séries temporelles, notamment la classification, le clustering, la prévision et la détection d'anomalies. Vous pouvez par exemple utiliser l'analyse de séries temporelles pour prédire les ventes mensuelles de manteaux d'hiver à partir des données de vente historiques.</p>
<p><a name="training"></a>
</p><h2 class="hide-from-toc"> apprentissage (training)</h2><p></p>
<p>Processus consistant à déterminer les <a href="#parameter"><strong>paramètres</strong></a> idéaux d'un modèle.</p>
<p><a name="training_set"></a>
</p><h2 class="hide-from-toc"> ensemble d'apprentissage (training set)</h2><p></p>
<p>Sous-ensemble de l'ensemble de données utilisé pour entraîner un modèle.</p>
<p>À comparer à l'<a href="#validation_set"><strong>ensemble de validation</strong></a> et à l'<a href="#test_set"><strong>ensemble d'évaluation</strong></a>.</p>
<p><a name="transfer_learning"></a>
</p><h2 class="hide-from-toc"> apprentissage par transfert (transfer learning)</h2><p></p>
<p>Transfert d'informations d'une tâche de machine learning à une autre.
Par exemple, dans un apprentissage multitâche, un seul modèle résout plusieurs tâches. C'est le cas des <a href="#deep_model"><strong>modèles profonds</strong></a>, qui ont différents nœuds de sortie pour différentes tâches.  L'apprentissage par transfert peut impliquer le transfert de connaissances issues de la solution d'une tâche plus simple vers une tâche plus complexe, ou le transfert de connaissances tirées d'une tâche contenant de nombreuses données vers une tâche en contenant moins.</p>
<p>La plupart des systèmes de machine learning résolvent <em>une seule</em> tâche. L'apprentissage par transfert est un petit pas vers l'intelligence artificielle, en ce qu'un seul programme peut résoudre <em>plusieurs</em> tâches.</p>
<p><a name="translational_invariance"></a>
</p><h2 class="hide-from-toc"> invariance de translation (translational invariance)</h2><p></p>
<p>Dans un problème de classification d'images, capacité d'un algorithme à classer correctement des images même lorsque la position des objets dans l'image change.
Par exemple, l'algorithme peut identifier un chien comme tel, qu'il se trouve au centre ou à gauche de l'image.</p>
<p>Voir aussi <a href="#size_invariance"><strong>invariance de taille</strong></a> et <a href="#rotational_invariance"><strong>invariance rotationnelle</strong></a>.</p>
<p><a name="TN"></a>
</p><h2 class="hide-from-toc"> vrai négatif (VN) (true negative (TN))</h2><p></p>
<p>Exemple dans lequel le modèle a prédit <em>correctement</em> la <a href="#negative_class"><strong>classe négative</strong></a>. Par exemple, le modèle a déduit qu'un e-mail particulier n'était pas du spam, ce qui était bien le cas.</p>
<p><a name="TP"></a>
</p><h2 class="hide-from-toc"> vrai positif (VP) (true positive (TP))</h2><p></p>
<p>Exemple dans lequel le modèle a prédit <em>correctement</em> la <a href="#positive_class"><strong>classe positive</strong></a>. Par exemple, le modèle a déduit qu'un e-mail particulier était du spam, ce qui était bien le cas.</p>
<p><a name="TP_rate"></a>
</p><h2 class="hide-from-toc"> taux de vrais positifs (taux de VP) (true positive rate (TP rate))</h2><p></p>
<p>Synonyme de <a href="#recall"><strong>rappel</strong></a>. C'est-à-dire :</p>
<div>
$$\text{Taux de vrais positifs} = \frac{\text{Vrais positifs}} {\text{Vrais positifs} + \text{Faux négatifs}}$$
</div>

<p>Le taux de vrais positifs correspond à l'axe des ordonnées d'une <a href="#ROC"><strong>courbe ROC</strong></a>.</p>

<p><a name="unlabeled_example"></a>
</p><h2 class="hide-from-toc"> exemple sans étiquette (unlabeled example)</h2><p></p>
<p>Exemple qui contient des <a href="#feature"><strong>caractéristiques</strong></a>, mais pas d'<a href="#label"><strong>étiquettes</strong></a>.
Les exemples sans étiquette sont les entrées des <a href="#inference"><strong>inférences</strong></a>. Dans l'apprentissage <a href="#semi-supervised_learning"><strong>partiellement supervisé</strong></a> ou <a href="#unsupervised_machine_learning"><strong>non supervisé</strong></a>, les exemples sans étiquette sont utilisés pendant l'apprentissage.</p>
<p><a name="unsupervised_machine_learning"></a>
</p><h2 class="hide-from-toc"> machine learning non supervisé (unsupervised machine learning)</h2><p></p>
<p>Entraînement d'un <a href="#model"><strong>modèle</strong></a> pour détecter des schémas dans un ensemble de données, généralement sans étiquette.</p>
<p>Le machine learning non supervisé est surtout utilisé pour regrouper les données dans des clusters d'exemples similaires. Par exemple, un algorithme de machine learning non supervisé peut regrouper des titres selon leurs diverses caractéristiques. Les clusters qui en résultent peuvent être utilisés comme entrées d'autres algorithmes de machine learning (par exemple, un service de recommandation de musique).
Le clustering peut être utile dans les domaines où les vraies étiquettes sont difficiles à obtenir.
Par exemple, dans les domaines tels que la lutte contre les abus et la fraude, les clusters peuvent aider à mieux comprendre les données.</p>
<p>Un autre exemple de machine learning non supervisé est l'<a href="https://en.wikipedia.org/wiki/Principal_component_analysis"><strong>analyse en composantes principales (PCA)</strong></a>.
Par exemple, l'application de la PCA sur un ensemble de données contenant des millions de paniers d'achat peut révéler que ceux contenant des citrons contiennent également fréquemment des antiacides.</p>
<p>À comparer avec le <a href="#supervised_machine_learning"><strong>machine learning supervisé</strong></a>.</p>

<p><a name="validation_set"></a>
</p><h2 class="hide-from-toc"> ensemble de validation (validation set)</h2><p></p>
<p>Sous-ensemble de l'ensemble de données, distinct de l'ensemble d'apprentissage, utilisé pour ajuster les <a href="#hyperparameter"><strong>hyperparamètres</strong></a>.</p>
<p>À comparer avec l'<a href="#training_set"><strong>ensemble d'apprentissage</strong></a> et l'<a href="#test_set"><strong>ensemble d'évaluation</strong></a>.</p>
</p>

<p><a name="weight"></a>
</p><h2 class="hide-from-toc"> pondération (weight)</h2><p></p>
<p>Coefficient d'une <a href="#feature"><strong>caractéristique</strong></a> d'un modèle linéaire, ou frontière d'un réseau profond. L'entraînement d'un modèle linéaire vise à déterminer la pondération idéale de chaque caractéristique. Si la pondération est égale à 0, la caractéristique correspondante ne contribue pas au modèle.</p>
<p><a name="wide_model"></a>
</p><h2 class="hide-from-toc"> modèle large (wide model)</h2><p></p>
<p>Modèle linéaire qui contient généralement un grand nombre de <a href="#sparse_features"><strong>caractéristiques d'entrée creuses</strong></a>. Ce modèle est dit "large", car il s'agit d'un type particulier de <a href="#neural_network"><strong>réseau de neurones</strong></a> comportant un grand nombre d'entrées connectées directement au nœud de sortie. Les modèles larges sont souvent plus faciles à déboguer et à inspecter que les modèles profonds. Bien qu'ils ne puissent pas exprimer les non-linéarités par le biais de <a href="#hidden_layer"><strong>couches cachées</strong></a>, les modèles larges peuvent utiliser des transformations comme le <a href="#feature_cross"><strong>croisement de caractéristiques</strong></a> et le <a href="#bucketing"><strong>binning</strong></a> pour modéliser les non-linéarités de différentes manières.</p>
<p>À comparer avec le <a href="#deep_model"><strong>modèle profond</strong></a>.</p>
